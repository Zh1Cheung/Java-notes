## ARP

（ARP地址解析协议,  RARP反向地址解析协议），我们习惯上把它们认为是链路层的协议，实际上，从分层的角度来看，更准确的说是，（应该是一种介于网络IP层与链路层之间的一种协议）

我们知道在ISO/OSI模型中，数据在传输的过程中，有不断封装过程，到了链路层的话(以太网传输)，在以太网的帧格式中会出现目的主机的MAC地址，但是我们从一开始就只知道目的主机的IP地址，所以这里用到了ARP协议

源主机先在自己的ARP缓冲区中寻找映射，如果有（直接填充于以太网帧中），如果没有，通过路由广播请求，这时一些联网的主机就会收到这个请求，并将这个请求传回网络层，对比IP地址，检验是否可以接受，如果不行，则直接丢失这个信息，如果可以那么回复ARP请求，并且将源主机的MAC地址加入到目的ARP缓冲区中，形成映射，源主机接受到请求后，将目的的MAC地址加入到ARP缓冲区，也形成映射，并将mac地址传输至连接层。此时转化完成

![img](https://img-blog.csdn.net/20160219211855357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**什么是ARP欺骗**

举个栗子：

| 主机 |     IP      |        MAC        |
| :--: | :---------: | :---------------: |
|  A   | 192.168.1.1 | 0A-11-22-33-44-01 |
|  B   | 192.168.1.2 | 0A-11-22-33-44-02 |
|  C   | 192.168.1.3 | 0A-11-22-33-44-03 |

> 1.主机A要和主机C通信，主机A发出ARP包询问谁是192.168.1.3?请回复192.168.1.1
>
> 2.这时主机B在疯狂的向主机A回复，我是192.168.1.3，我的地址是0A-11-22-33-44-02
>
> 3.由于ARP协议不会验证回复者的身份，造成主机A错误的将192.168.1.3的MAC映射为0A-11-22-33-44-02。

**ARP欺骗的分类**

> 1.主机欺骗，如同上面的栗子，主机B欺骗局域网中的主机A。
>
> 2.网关欺骗，局域网中的主机欺骗网关，从而获取其他主机的进流量。

**如何防御ARP欺骗**

ARP欺骗是通过重复应答实现的，那么只需要在本机添加一条静态的ARP映射，这样就不需要询问网关MAC地址了，这种方法只对主机欺骗有效。对于网关欺骗还需要在网关中也添加一条到主机的静态ARP映射。1.用管理身份运行命令提示符；输入netsh i i show in，查看一下本机有哪些网络连接

```
netsh i i show in
```

2.查看一下网关的MAC地址。注意如果正遭受ARP欺骗攻击，通过此方法查处的可能是虚假的MAC地址。输入arp -a命令查询本机的arp映射表，如果找不到网关的信息，可以先ping一下网关。

3.输入：netsh -c "i i" add neighbors 连接的Idx号 网关IP 网关MAC 添加一条静态映射,我已经添加过了，所以会显示 对象已存在

```
netsh -c "i i" add neighbors 连接的Idx号 网关IP 网关MAC
netsh -c "i i" add neighbors 9 10.60.12.1 4c-5e-0c-64-73-f5
```



## DNS

- 你肯定记得住网站的名称，但是很难记住网站的IP地址，因而也需要一个地址簿，就是**DNS**服务器。
  - 由此可见，DNS在日常生活中多么重要。每个人上网，都需要访问它，但是同时，这对它来讲也是非常 大的挑战。一旦它出了故障，整个互联网都将瘫痪。另外，上网的人分布在全世界各地，如果大家都去 同一个地方访问某一台服务器，时延将会非常大。因而，**DNS服务器，一定要设置成高可用、高并发 和分布式的**。
  - 于是，就有了**树状的层次结构**。
    - 根DNS服务器 :返回顶级域DNS服务器的IP地址 
    - 顶级域DNS服务器:返回权威DNS服务器的IP地址 
    - 权威DNS服务器 :返回相应主机的IP地址
- **DNS**解析流程
  - 客户端——本地DNS缓存（etc/hosts）—本地DNS服务器——根DNS服务器——顶级域DNS服务器——权威DNS服务器
- 负载均衡
  - 在客户端角度，这是一次**DNS递归查询过程。**因为本地DNS全权为它效劳，它只要坐等结果即可。 在这个过程中，DNS除了可以通过名称映射为IP地址，它还可以做另外一件事，就是**负载均衡**。
  - DNS首先可以做**内部负载均衡**。
    - **例如，一个应用要访问数据库**，在这个应用里面应该配置这个数据库的IP地址，还是应该配置这个数据 库的域名呢?显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如 果有多个应用都配置了这台数据库的话，一换IP地址，就需要将这些应用全部修改一遍。但是如果配置 了域名，则只要在DNS服务器里，将域名映射为新的IP地址，这个工作就完成了，大大简化了运维。
    - **在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用**，如果配置另外一个应用 的IP地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。 但是，访问它的应用，如何在多个之间进行负载均衡?只要配置成为域名就可以了。在域名解析的时 候，我们只要配置策略，这次返回第一个IP，下次返回第二个IP，就可以实现负载均衡了。
  - 另外一个更加重要的是，DNS还可以做**全局负载均衡**。
    - 为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的IP地址。**当用户访问某个 域名的时候，这个IP地址可以轮询访问多个数据中心。**如果一个数据中心因为某种原因挂了，只要在DNS服务器里面，将这个数据中心对应的IP地址删除，就可以实现一定的高可用。
    - **另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体 验就会非常好，访问速度就会超快。这就是全局负载均衡的概念**。
- 在域名和IP的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地域和运营商做全局的负载均衡。
  - 对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而 需要专门的设备或者服务器来做这件事情，这就是**全局负载均衡器**(**GSLB**，**Global Server Load Balance**)。
  - 例如两层的GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机 房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延。
    - 第一层GSLB，通过查看请求它的本地DNS服务器所在的运营商，就知道用户所在的运营商。假设 是移动，通过CNAME的方式，通过另一个别名 object.yd.yourcompany.com，告诉本地DNS服务 器去请求第二层的GSLB。
    - 第二层GSLB，通过查看请求它的本地DNS服务器所在的地址，就知道用户所在的地理位置，然后 将距离用户位置比较近的Region里面，六个**内部负载均衡**(**SLB**，S**erver Load Balancer**)的地 址，返回给本地DNS服务器。
    - 本地DNS服务器将结果返回给本地DNS解析器。
    - 本地DNS解析器将结果缓存后，返回给客户端。
    - 客户端开始访问属于相同运营商的距离较近的Region 1中的对象存储，当然客户端得到了六个IP地 址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个 备份，从而可以实现对存储读写的负载均衡。

- 层次树状结构的联机分布式数据库系统
  - 产生于应用层上的域名系统 NDS就可以用来把互联网上的主机名转换成 IP 地址
  - 把待解析的域名放在 DNS 的请求报中，以 UDP 用户数据报方式发送给本地域名服务器。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。获得 IP 地址的后主机即可进行通信
- 域名解析过程
  - 域名解析过程
    - 本地域名服务器向根域名服务器的查询方式通常采取迭代查询
  - 递归查询
    - 主机向本地域名服务器的查询一般都采用递归查询

**DNS劫持 vs HTTP劫持**

开始正式介绍DNS劫持之前，先与HTTP劫持做一个比较，可能有助于有些同学对下文更容易理解更深入一点。

DNS劫持现象：你输入一个google.com网址，出来的是百度的页面

HTTP劫持现象：访问着github的页面，右下角出现了一个格格不入的广告弹窗

在dns解析过程中，有哪一环节出现问题的话，都可能会导致DNS解析错误，导致客户端（浏览器）得到一个假的ip地址，从而引导用户访问到这个冒名顶替，恶意的网站。

**下面大概说几种DNS劫持方法**

**1.本机DNS劫持**

攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地DNS配置，比如修改本地hosts文件，缓存等

**2. 路由DNS劫持**

很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置

**3.攻击DNS服务器**

直接攻击DNS服务器，例如对DNS服务器进行DDOS攻击，可以是DNS服务器宕机，出现异常请求，还可以利用某些手段感染dns服务器的缓存，使给用户返回来的是恶意的ip地址

**2.DNS的防范**

> 就这上面的劫持方法，说几种方法手段

1.加强本地计算机病毒检查，开启防火墙等，防止恶意软件，木马病毒感染计算机

2.改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器

3.企业的话可以准备两个以上的域名，一旦一个域名挂掉，还可以使用另一个

4.用HTTP DNS 代替 Local DNS

> 对于DNS劫持，往往单靠个人设置很难解决，如果已经出现了劫持现象的话，对电脑进去杀毒，清理，检查hosts文件，核查网络设置的DNS配置（可以使用写公共的DNS服务器





## HTTPDNS

- 传统**DNS**存在哪些问题?
  - 域名缓存问题
    - 它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威DNS服务器，而是访问过一 次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。
    - 另外，有的运营商会把一些静态页面，缓存到本运营商的服务器内，这样用户请求的时候，就不用跨运 营商进行访问，这样既加快了速度，也减少了运营商之间流量计算的成本。
    - **很多情况下是看不出问题的，但是当页面更新，用户会访问到老的页面，问题就出来了。**
    - **再就是本地的缓存，往往使得全局负载均衡失败**，因为上次进行缓存的时候，缓存中的地址不一定是这 次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路。
  - 域名转发问题
    - 缓存问题还是说本地域名解析服务，还是会去权威DNS服务器中查找，只不过不是每次都要查找。
    - 如果是A运营商的客户，访问自己运营商的DNS服务器，如果A运营商去权威DNS服务 器查询的话，权威DNS服务器知道你是A运营商的，就返回给一个部署在A运营商的网站地址，这样针 对相同运营商的访问，速度就会快很多。
    - 但是A运营商偷懒，将解析的请求转发给B运营商，B运营商去权威DNS服务器查询的话，权威服务器会误认为，你是B运营商的，那就返回给你一个在B运营商的网站地址吧，结果**客户的每次访问都要跨运营商，速度就会很慢**。
  - 出口**NAT**问题
    - 出口的时候，很多机房都会配置**NAT**，也即**网络地址转换**，使得从 这个网关出去的包，都换成新的IP地址，当然请求返回的时候，在这个网关，再将IP地址转换回去，所 以对于访问来说是没有任何问题。
    - **但是一旦做了网络地址的转换，权威的DNS服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，**而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。
  - 域名更新问题
    - **本地DNS服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别**，有的会偷懒，忽略域名解析结果的TTL时间限制，在权威DNS服务器解析变更的时候，解析结果在 全网生效的周期非常漫长。但是有的时候，在DNS的切换中，场景对生效时间要求比较高。
    - 例如**双机房部署**的时候，**跨机房的负载均衡和容灾多使用DNS来做**。当一个机房出问题之后，需要修改 权威DNS，将域名指向新的IP地址，但是如果更新太慢，那很多用户都会出现访问异常。
  - 解析延迟问题
    - DNS的查询过程需要递归遍历多个DNS服务器，才能获得最终的解析结 果，这会带来一定的时延，甚至会解析超时。
- **HTTPDNS**的工作模式
  - 









## CDN

- 内容分发网络，解决的是如何将数据快速可靠从源站传递到用户

- 数据从服务器端交付到用户端，至少有4个地方可能会造成网络拥堵

  - 网站服务器接入互联网的链路
  - 用户接入互联网的链路
  - ISP互联，即因特网服务提供商之间的互联
  - 长距离传输时延问题

- 基本过程

  - 用户在浏览器中输入要访问的域名。 

  2. 浏览器向DNS服务器请求对域名进行解析。由于CDN对域名解析进行了调整，DNS服务器会最终将域名的解析权交给CDN专用DNS服务器。 
  3. CDN的DNS服务器将CDN的负载均衡设备IP地址返回给用户。 
  4. 用户向CDN的负载均衡设备发起内容URL访问请求。 

  - CDN负载均衡设备会为用户选择一台合适的缓存服务器提供服务。 
    5. 选择的依据包括：根据用户IP地址，判断哪一台服务器距离用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器的负载情况，判断哪一台服务器的负载较小。 

  5. 用户向缓存服务器发出请求。
  6. 缓存服务器响应用户请求，将用户所需内容传送到用户。

7. CDN的工作原理：通过权威DNS服务器来实现最优节点的选择，通过缓存来减少源站的压力





## HTTP

- HTTP幂等性
  - 幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同
  - HTTP POST和PUT，二者均可用于创建资源，更为本质的差别是在幂等性方面
    - POST所对应的URI并非创建的资源本身，而是资源的接收者
      - 两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性
    - PUT所对应的URI是要创建或更新的资源本身
      - 对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性
- HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性
  - 三次握手有1.5个RTT（round-trip time）的延迟
  - 不同策略的http长链接方案
    - HTTP的长连接和短连接本质上是TCP长连接和短连接
  - TCP在建立连接的初期有慢启动
- http和socket长连接和短连接区别
  - Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口
  - 门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议
- HTTP2.0
  - HTTP1.x有以下几个主要缺点：
    - 一次只允许在一个TCP连接上发起一个请求
    - HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
    - 单向请求，只能由客户端发起。
    - 请求报文与响应报文首部信息冗余量大。
    - 数据未压缩，导致数据的传输量大。
  - 多路复用 (Multiplexing)
    - 所谓多路复用，即在一个TCP连接中存在多个流
    - HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟
  - 二进制分帧
    - 很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧
    - HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。
      帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
  - 首部压缩（Header Compression）
  - 服务端推送（Server Push）
- 哈希算法
  - 将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。







## GET/POST

- 区别
  - GET请求在URL中传送的参数是有长度限制的，而POST没有。
    - 对于一个字节流的解析，必须分配buffer来保存所有要存储的数据。而URL这种东西必须当作一个整体看待，无法一块一块处理，于是就处理一个URL请求时必须分配一整块足够大的内存
  - 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数
  - GET和POST本质上没有区别
    - HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议
    - HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本
    - GET和POST的底层也是TCP/IP，GET/POST都是TCP链接
    - GET产生一个TCP数据包；POST产生两个TCP数据包
  - 从攻击的角度，无论是GET还是POST都不够安全
    - HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上传播，不管是url，header还是body
- ElasticSearch的_search接口使用GET，却用body来表达查询，因为查询很复杂





## RestTemplate

- RestTemplate能大幅简化了提交表单数据的难度，并且附带了自动转换JSON数据的功能

  | HTTP method | RestTemplate methods |
  | :---------- | :------------------- |
  | DELETE      | delete               |
  | GET         | getForObject         |
  |             | getForEntity         |
  | HEAD        | headForHeaders       |
  | OPTIONS     | optionsForAllow      |
  | POST        | postForLocation      |
  |             | postForObject        |
  | PUT         | put                  |
  | any         | exchange             |
  |             | execute              |

- 手动指定转换器(HttpMessageConverter)

  - 调用reseful接口传递的数据内容是json格式的字符串，返回的响应也是json格式的字符串
  - restTemplate.postForObject方法的请求参数RequestBean和返回参数ResponseBean都是java类。是RestTemplate通过HttpMessageConverter自动帮我们做了转换的操作
    - StringHttpMessageConverter来处text/plain;
    - MappingJackson2HttpMessageConverter来处理application/json;
    - MappingJackson2XmlHttpMessageConverter来处理application/xml

- RestTemplate直接使用一个HttpClient作为底层实现

- 设置拦截器(ClientHttpRequestInterceptor)

  - ```java
    // 1.实现ClientHttpRequestInterceptor接口
    
    
    RestTemplate restTemplate = new RestTemplate();
    // 2.向restTemplate中添加自定义的拦截器
    restTemplate.getInterceptors().add(new TokenInterceptor());
    ```

- getForObject()其实比getForEntity()多包含了将HTTP转成POJO的功能，但是getForObject没有处理response的能力。因为它拿到手的就是成型的pojo。省略了很多response的信息

- postForEntity

  - ```java
    // httpEntity
    HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(map, headers);
    ResponseEntity<String> response = restTemplate.postForEntity( url, request , String.class );
    
    // MultiValueMap是Map的一个子类，它的一个key可以存储多个value
    
    // 为什么用MultiValueMap?因为HttpEntity接受的request类型是它
    
    // 为什么用HttpEntity是因为restTemplate.postForEntity方法虽然表面上接收的request是@Nullable Object request类型，但是你追踪下去会发现这个request是用HttpEntity来解析
    ```

- 使用exchange指定调用方式

  ```java
  HttpEntity<String> entity = new HttpEntity<>(jsonObj.toString(), headers);
  ResponseEntity<JSONObject> exchange = restTemplate.exchange(url,HttpMethod.GET, entity, JSONObject.class);
  ```





