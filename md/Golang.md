# 工作区和GOPATH

- 3 个环境变量
  - GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。
  - GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。
    - 你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，**每个目录都代表 Go 语言的一个工作区**（workspace）。
    - 我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）
      - 归档文件在Linux下就是扩展名是.a的文件，也就是archive文件，这是程序编译后生成的静态库文件
  - GOBIN：GO 程序生成的可执行文件（executable file）的路径

- Go 语言源码的组织方式
  - 与许多编程语言一样，Go 语言的源码也是以代码包为基本组织单位的
  - 在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。
  - 所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。
  - 某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中





# 库源码文件

- 库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。

  - 在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。

  - 为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致。

    - ```go
      // 故意让声明的包名与其所在的目录的名称不同
      package lib5
       
      import "fmt"
       
      // 首字母大写的Hello
      func Hello(name string) {
      	fmt.Printf("Hello, %s!\n", name)
      }
      
      ---
      
      ./demo5.go:5:2: imported and not used: "puzzlers/article3/q2/lib" as lib5
      ./demo5.go:16:2: undefined: lib
      ```

    - 有两个方式可以使上述构建成功完成。我在这里选择把 demo5_lib.go 文件中的代码包声明语句改为`package lib`。

- 什么样的程序实体才可以被当前包外的代码引用

  - 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。
  - 包名不需要和其所在的文件夹名相同
  - 通过名称，Go 语言自然地把程序实体的访问权限划分为了包级私有的和公开的。对于包级私有的程序实体，即使你导入了它所在的代码包也无法引用到它。





# 程序实体

- var name string

  - 这里利用了 Go 语言自身的类型推断，而省去了对该变量的类型的声明。
    - 类型推断是一种编程语言在编译期自动解释表达式类型的能力
    - 表达式类型就是对表达式进行求值后得到结果的类型。Go 语言中的类型推断是很简约的，这也是 Go 语言整体的风格。
    - 它只能用于对变量或常量的初始化。

- name := flag.String("name", "everyone", "The greeting object.")

  - 对`flag.String`函数的调用其实就是一个调用表达式，而这个表达式的类型是`*string`，即字符串的指针类型。
  - 这也是调用`flag.String`函数后得到结果的类型。随后，Go 语言把这个调用了`flag.String`函数的表达式类型，直接作为了变量`name`的类型，这就是“推断”一词所指代的操作了。
  - var name string ---基于类型推断->var name ="aaa" or name := "aaa"

- Go 语言的类型推断可以带来哪些好处

  - ```go
    package main
     
    import (
    	"flag"
    	"fmt"
    )
     
    func main() {
    	var name = getTheFlag()
    	flag.Parse()
    	fmt.Printf("Hello, %v!\n", *name)
    }
     
    func getTheFlag() *string {
    	return flag.String("name", "everyone", "The greeting object.")
    }
    ```

  - 这样一来，`var name =`右边的表达式，可以变为针对`getTheFlag`函数的调用表达式了。这实际上是对“声明并赋值`name`变量的那行代码”的重构。

  - 我们不显式地指定变量`name`的类型，使得它可以被赋予任何类型的值。也就是说，变量`name`的类型可以在其初始化时，由其他程序动态地确定。

  - Go 语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。这就避免了在后面维护程序时的一些问题。另外，请记住，**这种类型的确定是在编译期完成的，因此不会对程序的运行效率产生任何影响。**

  - **如果只用一两句话回答这个问题的话，我想可以是这样的**：Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。

- 变量的重声明
  
  - 通过使用它，我们可以对同一个代码块中的变量进行重声明。
    
    - 在 Go 语言中，**代码块**一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。
    - 这种代码块的划分，也间接地决定了程序实体的作用域。
    
  - 变量重声明的前提条件如下
  
    - 由于变量的类型在其初始化时就已经确定了，所以**对它再次声明时赋予的类型必须与其原本的类型相同**，否则会产生编译错误。
    - **变量的重声明只可能发生在某一个代码块中。**如果与当前的变量重名的是外层代码块中的变量，当前变量覆盖外层变量。
    - **变量的重声明只有在使用短变量声明时才会发生**，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字`var`的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。
    - **被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量**。这时我们才可以说对其中的旧变量进行了重声明。
  
  - ```go
    var err error
    n, err := io.WriteString(os.Stdout, "Hello, everyone!\n")
    ```
  
  - 变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。
  
- 一个程序实体被创造出来，是为了让别的代码引用的。那么，哪里的代码可以引用它呢，这就涉及了它的作用域。

  - 序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。
  - **一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。**对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里开始。

- **如果一个变量与其外层代码块中的变量重名会出现什么状况**

  - ```go
    package main
     
    import "fmt"
    
    // 这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。
    
    var block = "package"
     
    // 在后三个代码块中分别声明了一个名为block的变量，并分别把字符串值"package"、"function"和"inner"赋给了它们。
    func main() {
    	block := "function"
    	{
    		block := "inner"
    		fmt.Printf("The block is %s.\n", block)
    	}
    	fmt.Printf("The block is %s.\n", block)
    }
    
    
    ---
    
    The block is inner.
    The block is function.
    
    ```

  - 查找过程

    - 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
    - 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。
    - 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了

  - 如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。

    - 但有个特殊情况，如果我们把代码包导入语句写成`import . XXX`的形式（注意中间的那个“.”），那么就会让这个“XXX”包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。
    - 比如，如果有代码包导入语句`import . fmt`，那么我们在当前源码文件中引用`fmt.Printf`函数的时候直接用`Printf`就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。

- **不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿**

  > **把不同代码块中的重名变量叫做“可重名变量”**

  

  - 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
  - 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
  - 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
  - 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

- **怎样判断一个变量的类型**

  - 使用“类型断言”表达式

    - 类型断言表达式的语法形式是`x.(T)`。其中的`x`代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。

    - ```go
      
      /*
      
      它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string 的 .([]string)。
      
      这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。但是这样的话，当判断为否时就会引发异常。
      
      这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。
      
      */
      
      /*
      
      在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。
      []string是一个类型字面量。所谓类型字面量，就是用来表示数据类型本身的若干个字符。
      比如，string是表示字符串类型的字面量，uint8是表示 8 位无符号整数类型的字面量。
      
      */
      
      value, ok := interface{}(container).([]string)
      ```

  - **请记住，一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。**

    - 比如`struct{}`，它就代表了不包含任何字段和方法的、空的结构体类型。
    - 而空接口`interface{}`则代表了不包含任何方法定义的、空的接口类型。

- 类型转换

  - 对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。

    - 当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。
    - 比如，`int16`类型的值`-255`的补码是`1111111100000001`。如果我们把该值转换为`int8`类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到`00000001`。
    - 正数的补码等于原码，负数的补码才是反码＋1

  - 虽然直接把一个整数值转换为一个`string`类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是`"�"`（仅由高亮的问号组成的字符串值）。

    - ```go
      // 由于-1肯定无法代表一个有效的 Unicode 代码点，所以得到的总会是"�"。在实际工作中，我们在排查问题时可能会遇到�，你需要知道这可能是由于什么引起的。
      
      string(-1)
      ```

  - `string`类型与各种切片类型之间的互转

    - 一个值在从`string`类型向`[]byte`类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。

    - 除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。

      - ```go
        string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
        
        ```

#  数组和切片

- **数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。**

  - 数组的长度在声明它的时候就必须给定，而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。
  - **我们其实可以把切片看做是对数组的一层简单的封装**，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。
  - 也正因为如此，Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。
    - 在 Go 语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。

- 怎样正确估算切片的长度和容量

  - 我们通过调用内建函数`len`，得到数组和切片的长度。通过调用内建函数`cap`，我们可以得到它们的容量。

  - 但要注意，数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有规律可寻的。

  - ```go
    	// 示例 1。
      	s1 := make([]int, 5)
      	fmt.Printf("The length of s1: %d\n", len(s1))
      	fmt.Printf("The capacity of s1: %d\n", cap(s1))
      	fmt.Printf("The value of s1: %d\n", s1)
      	s2 := make([]int, 5, 8)
      	fmt.Printf("The length of s2: %d\n", len(s2))
      	fmt.Printf("The capacity of s2: %d\n", cap(s2))
      	fmt.Printf("The value of s2: %d\n", s2)
      
    // 切片s1和s2的容量分别是5和8
    // 当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了
    
    
    ---
    
    s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
    s4 := s3[3:6]
    fmt.Printf("The length of s4: %d\n", len(s4))
    fmt.Printf("The capacity of s4: %d\n", cap(s4))
    fmt.Printf("The value of s4: %d\n", s4)
    
    /*
    由于s4是通过在s3上施加切片操作得来的，所以s3的底层数组就是s4的底层数组。
    又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。
    所以，s4的容量就是其底层数组的长度8, 减去上述切片表达式中的那个起始索引3，即5。
    
    注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过`s4`看到`s3`中最左边的那 3 个元素。
    对于`s4`来说，切片表达式`s4[0:cap(s4)]`就可以做到。我想你应该能看懂。该表达式的结果值（即一个新的切片）会是`[]int{4, 5, 6, 7, 8}`，其长度和容量都是`5`。
    
    */
    ```

- 怎样估算切片容量的增长

  - 一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。**在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。**
  - **但是，当原切片的长度（以下简称原长度）大于或等于`1024`时，Go 语言将会以原容量的`1.25`倍作为新容量的基准（以下新容量基准）。**新容量基准会被调整（不断地与`1.25`相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。
  - **另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。**注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见`runtime`包中 slice.go 文件里的`growslice`及相关函数的具体实现。

- 切片的底层数组什么时候会被替换

  - 确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。
  - 请记住，在无需扩容时，`append`函数返回的是指向原底层数组的新切片，而在需要扩容时，`append`函数返回的是指向新底层数组的新切片。

- 只要新长度不会超过切片的原容量，那么使用`append`函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。

- 创建 slice 的开销很小。不过执行 append 有可能（注意，不是每次）会造成内存的申请和元素值的拷贝。这属于不可忽视的开销。

  - 切片本身有着占用内存少和创建便捷等特点，但它的本质上还是数组。切片的一大好处是可以让我们通过窗口快速地定位并获取，或者修改底层数组中的元素。
  - 不过，当我们想删除切片中的元素的时候就没那么简单了。元素复制一般是免不了的，就算只删除一个元素，有时也会造成大量元素的移动。这时还要注意空出的元素槽位的“清空”，否则很可能会造成内存泄漏。
  - 对比来看，一个链表所占用的内存空间，往往要比包含相同元素的数组所占内存大得多。这是由于链表的元素并不是连续存储的，所以相邻的元素之间需要互相保存对方的指针。不但如此，每个元素还要存有它所属链表的指针。

- 如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？

  - 当两个长度不一的切片使用同一个底层数组，并且两切片的长度均小于数组的容量时，对其中长度较小的一个切片进行append操作，但不超过底层数组容量，这时会影响长度较长切片中原来比较小切片多看到的值，因为底层数组被修改了。

  - 底层数组的变动会影响多个切片





# container包中的那些容器

- Go 语言的链表实现在标准库的`container/list`代码包中。这个代码包中有两个公开的程序实体——`List`和`Element`，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。

- 可以把自己生成的`Element`类型值传给链表吗

  - 不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的`Element`值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的`Element`值插入其中

  - 我们在这里用到了`List`的四种方法。

    - ```go
      /*
      `MoveBefore`方法和`MoveAfter`方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。
      `MoveToFront`方法和`MoveToBack`方法，分别用于把给定的元素移动到链表的最前端和最后端。
      
      List的方法还有下面这几种：
      
      Front和Back方法分别用于获取链表中最前端和最后端的元素，
      InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素，PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。
      
      */
      func (l *List) MoveBefore(e, mark *Element)
      func (l *List) MoveAfter(e, mark *Element)
       
      func (l *List) MoveToFront(e *Element)
      func (l *List) MoveToBack(e *Element)
      
      ```

    - 在`List`包含的方法中，用于插入新元素的那些方法都只接受`interface{}`类型的值。这些方法在内部会使用`Element`值，包装接收到的新元素。

    - **这样做正是为了避免直接使用我们自己生成的元素**，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。

- 为什么链表可以做到开箱即用

  - `List`和`Element`都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。
    - 比如，经过语句`var a [2]int`声明的变量`a`的值，将会是一个包含了两个`0`的整数数组。又比如，经过语句`var s []int`声明的变量`s`的值将会是一个`[]int`类型的、值为`nil`的切片。
  - **Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。**这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一
    - 所谓的**延迟初始化**，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。
      - 链表的`PushFront`方法、`PushBack`方法、`PushBackList`方法以及`PushFrontList`方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。
      - 而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。
      - **`List`利用了自身以及`Element`在结构上的特点，巧妙地平衡了延迟初始化的优缺点**，使得链表可以开箱即用，并且在性能上可以达到最优。
    - 例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。
    - **如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。**
    - 实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用

- `Ring`与`List`的区别

  - `container/ring`包中的`Ring`类型实现的是一个循环链表，也就是我们俗称的环。其实`List`在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。
    - 所以也可以说，`List`的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。
  - `Ring`类型的数据结构仅由它自身即可代表，而`List`类型则需要由它以及`Element`类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。
  - 一个`Ring`类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个`List`类型的值则代表了一个完整的链表。这是表示维度上的不同。
  - 在创建并初始化一个`Ring`值的时候，我们可以指定它包含的元素的数量，但是对于一个`List`值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的`New`函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。
  - 仅通过`var r ring.Ring`语句声明的`r`将会是一个长度为`1`的循环链表，而`List`类型的零值则是一个长度为`0`的链表。别忘了`List`中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。
  - `Ring`值的`Len`方法的算法复杂度是 O(N) 的，而`List`值的`Len`方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。

  

  

  

  

# 字典的操作和约束

- 为什么字典的键类型会受到约束
  - Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。
  - 如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。
  - **Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。**
    - Go 语言规范规定，在键类型的值之间必须可以施加操作符`==`和`!=`。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。
- 应该优先考虑哪些类型作为字典的键类型
  - **求哈希和判等操作的速度越快，对应的类型就越适合作为键类型**
  - 以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。
    - 类型的宽度是指它的单个值需要占用的字节数。比如，`bool`、`int8`和`uint8`类型的一个值需要占用的字节数都是`1`，因此这些类型的宽度就都是`1`。
  - 再来看高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上。
  - 与之类似，对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定
    - 我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。
- 在值为`nil`的字典上执行读操作会成功吗，那写操作呢
  - 除了添加键 - 元素对，我们在一个值为`nil`的字典上做任何操作都不会引起错误。当我们试图在一个值为`nil`的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。





# 通道

- Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）

- 通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。

  - 在初始化通道的时候，`make`函数除了必须接收这样的类型字面量作为参数，还可以接收一个`int`类型的参数。
    - **后者是可选的，用于表示该通道的容量。所谓通道的容量，就是指通道最多可以缓存多少个元素值。**由此，虽然这个参数是`int`类型的，但是它是不能小于`0`的。
    - 当容量为`0`时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于`0`时，我们可以称为缓冲通道，也就是带有缓冲的通道。
  - **一个通道相当于一个先进先出（FIFO）的队列。**也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。
  - **元素值的发送和接收都需要用到操作符`<-`**。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。

- 对通道的发送和接收操作都有哪些基本的特性

  - 对于同一个通道，发送操作之间是互斥的，接收操作之间也是**互斥**的。
    - **这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。**
  - 发送操作和接收操作中对元素值的处理都是**不可分割**的。
  - 发送操作在完全完成之前会被**阻塞**。接收操作也是如此。

- 发送操作和接收操作在什么时候可能被长时间的阻塞

  - 先说针对**缓冲通道**的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
    - 相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。
  - 对于**非缓冲通道**，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。
  - 对于值为`nil`的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。

- 发送操作和接收操作在什么时候会引发 panic

  - 对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。
  - 另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。
    - 更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定`bool`类型。它的值如果为`false`就说明通道已经关闭，并且再没有元素值可取了。
    - 注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是`true`。
    - 因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
  - 由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。

- 单向通道有什么应用价值

  - 概括地说，单向通道最主要的用途就是约束其他代码的行为。

  - ```go
    // 约束函数行为
    func SendInt(ch chan<- int) {
    	ch <- rand.Intn(1000)
    }
    
    ---
    
    // 我们在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为 Go 语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。
    
    type Notifier interface {
    	SendInt(ch chan<- int)
    }
    
    intChan1 := make(chan int, 3)
    SendInt(intChan1)
    
    ---
    
    // 函数getIntChan会返回一个<-chan int类型的通道，这就意味着得到该通道的程序，只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。
    func getIntChan() <-chan int {
    	num := 5
    	ch := make(chan int, num)
    	for i := 0; i < num; i++ {
    		ch <- i
    	}
    	close(ch)
    	return ch
    }
    ```

- `select`语句与通道怎样联用，应该注意些什么

  - `select`语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。
  - 由于`select`语句是专为通道而设计的，所以每个`case`表达式中都只能包含操作通道的表达式，比如接收表达式。
  - `select`语句只能对其中的每一个`case`表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在`for`语句中嵌入`select`语句的方式实现。但这时要注意，**简单地在`select`语句的分支中使用`break`语句，只能结束当前的`select`语句的执行，而并不会对外层的`for`语句产生作用**。这种错误的用法可能会让这个`for`语句无休止地运行下去。

- 如果在`select`语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支

  - 如果判断到chan关闭，即取到的第二个值为false。则将该chan赋值为nil。

- 在`select`语句与`for`语句联用时，怎样直接退出外层的`for`语句

  - ```go
    
    // 可以用 break和标签配合使用，直接break出指定的循环体，或者goto语句直接跳转到指定标签执行
    
    break配合标签：
    
    ch1 := make(chan int, 1)
    time.AfterFunc(time.Second, func() { close(ch1) })
    loop:
    for {
    select {
    case _, ok := <-ch1:
    if !ok {
    break loop
    }
    fmt.Println("ch1")
    }
    }
    fmt.Println("END")
    
    ---
    
    goto配合标签：
    
    ch1 := make(chan int, 1)
    time.AfterFunc(time.Second, func() { close(ch1) })
    for {
    select {
    case _, ok := <-ch1:
    if !ok {
    goto loop
    }
    fmt.Println("ch1")
    }
    }
    loop:
    fmt.Println("END")
    ```

    



# 函数

- 函数是一等的公民

  - 简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样

  - 而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。

  - ```go
    package main
     
    import "fmt"
     
    type Printer func(contents string) (n int, err error)
     
    func printToStd(contents string) (bytesNum int, err error) {
    	return fmt.Println(contents)
    }
     
    func main() {
    	var p Printer
    	p = printToStd
    	p("something")
    }
    ```

- 怎样编写高阶函数

  - 高阶函数可以满足下面的两个条件
    - 接受其他的函数作为参数传入
    - 把其他的函数作为结果返回
  - 只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数

- 通过编写`calculate`函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出

  - ```go
    import (
    	"errors"
    	"fmt"
    )
    
    type operate func(x, y int) int
    
    // 方案1。
    func calculate(x int, y int, op operate) (int, error) {
    	if op == nil {
    		return 0, errors.New("invalid operation")
    	}
    	return op(x, y), nil
    }
    
    // 方案2。
    type calculateFunc func(x int, y int) (int, error)
    
    // genCalculator函数内部，实际上就实现了一个闭包，而genCalculator函数也是一个高阶函数。
    // genCalculator函数只做了一件事，那就是定义一个匿名的、calculateFunc类型的函数并把它作为结果值返回。
    // 它里面使用的变量op既不代表它的任何参数或结果也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量。
    func genCalculator(op operate) calculateFunc {
    	return func(x int, y int) (int, error) {
        // 会发现op代表的是genCalculator函数的参数，然后，它会把这两者联系起来。这时可以说，自由变量op被“捕获”了。
        // 当程序运行到这里的时候，op就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。
    		if op == nil {
    			return 0, errors.New("invalid operation")
    		}
    		return op(x, y), nil
    	}
    }
    
    func main() {
    	// 方案1。
    	x, y := 12, 23
    	op := func(x, y int) int {
    		return x + y
    	}
    	result, err := calculate(x, y, op)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    	result, err = calculate(x, y, nil)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    
    	// 方案2。
    	x, y = 56, 78
    	add := genCalculator(op)
    	result, err = add(x, y)
    	fmt.Printf("The result: %d (error: %v)\n",
    		result, err)
    }
    ```

- 闭包的意义

  - 表面上看，我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。
  - 我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。这与 GoF 设计模式中的“模板方法”模式有着异曲同工之妙

- 传入函数的那些参数值后来怎么样了

  - 所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是它的副本。

  - 注意，对于引用类型，比如：切片、字典、通道，像上面那样复制它们的值，只会拷贝它们本身而已，并不会拷贝它们引用的底层数据。也就是说，这时只是浅表复制，而不是深层复制。

    - 以切片值为例，如此复制的时候，只是拷贝了它指向底层数组中某一个元素的指针，以及它的长度值和容量值，而它的底层数组并不会被拷贝。

  - 另外还要注意，就算我们传入函数的是一个值类型的参数值，但如果这个参数值中的某个元素是引用类型的，那么我们仍然要小心。

    - ```go
      // 变量complexArray1是[3][]string类型的，也就是说，虽然它是一个数组，但是其中的每个元素又都是一个切片。
      
      complexArray1 := [3][]string{
      	[]string{"d", "e", "f"},
      	[]string{"g", "h", "i"},
      	[]string{"j", "k", "l"},
      }
      ```

    - `complexArray1`被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗

      - 分2种情况，若是修改数组中的切片的某个元素，会影响原数组。若是修改数组的某个元素即a[1]=[]string{"x"}就不会影响原数组。
      - 谨记Go中都是浅拷贝，值类型和引用类型的区别

- 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗

  - 当函数返回指针类型时不会发生拷贝。当函数返回非指针类型并把结果赋值给其它变量肯定会发生拷贝





# 结构体及其方法

- 如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么

  - ```go
    type Animal struct {
    	scientificName string // 学名。
    	AnimalCategory    // 动物基本分类。
    }
    ```

  - 字段声明`AnimalCategory`代表了`Animal`类型的一个嵌入字段。Go 语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。

- 那如果我也为`Animal`类型编写一个`String`方法呢？这里会调用哪一个呢

  - 答案是，`animal`的`String`方法会被调用。这时，我们说，嵌入字段`AnimalCategory`的`String`方法被“屏蔽”了。注意，只要名称相同，无论这两个方法的签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。

  - 不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法，就像我在`Category`方法中所做的那样。这种“屏蔽”其实还带来了一些好处。我们看看下面这个`Animal`类型的`String`方法的实现：

    - ```go
      func (a Animal) String() string {
      	return fmt.Sprintf("%s (category: %s)",
      		a.scientificName, a.AnimalCategory)
      }
      ```

- Go 语言是用嵌入字段实现了继承吗

  - Go 语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的**组合**		
  - 简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过**侵入**的方式来实现的。
  - 类型之间的组合采用的是**非声明**的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。
  - 同时，类型组合也是**非侵入式**的，它不会破坏类型的封装或加重类型之间的耦合。
  - 我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。
  - 另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个类型的属性和能力“嫁接”给另一个类型。
  - 这时候，**被嵌入类型也就自然而然地实现了嵌入字段所实现的接口。**再者，组合要比继承**更加简洁和清晰**，Go 语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。

- **值方法和指针方法**

  - 方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。**所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。**

  - **值方法的接收者**是该方法所属的那个类型值的一个**副本**。我们在该方法内对该**副本的修改一般都不会体现在原值上**，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。

    - 而**指针方法的接收者**，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内**对该副本指向的值进行修改，却一定会体现在原值上**。

    - ```go
      func (cat *Cat) SetName(name string) {
      	cat.name = name
      }
      ```

  - **一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。**

    - 严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法
    - 比如，在`Cat`类型的变量`cat`之上，之所以我们可以通过`cat.SetName("monster")`修改猫的名字，是因为 Go 语言把它自动转译为了`(&cat).SetName("monster")`，即：先取`cat`的指针值，然后在该指针值上调用`SetName`方法。

- 我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？

  - 我们可以在结构体中嵌入某个类型的指针类型， 它和普通指针类似，默认初始化为nil,因此在用之前需要人为初始化，否则可能引起错误

- 字面量`struct{}`代表了什么？又有什么用处？

  - 空结构体不占用内存空间，但是具有结构体的一切属性，如可以拥有方法，可以写入channel。所以当我们需要使用结构体而又不需要具体属性时可以使用它。



# 接口类型

- 对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。这是一种无侵入式的接口实现方式。

- 当我们为一个接口变量赋值时会发生什么

  - ```go
    type Pet interface {
    	SetName(name string)
    	Name() string
    	Category() string
    }
    
    ---
    
    // pet变量的字段name的值依然是"little pig"
    dog := Dog{"little pig"}
    var pet Pet = dog
    dog.SetName("monster")
    
    
    // 这时的dog2的name仍然会是"little pig"。
    dog1 := Dog{"little pig"}
    dog2 := dog1
    dog1.name = "monster"
    
    
    ---
    // 运行后发现输出不仅d的name字段变为了“big dog”，同样pet接口变量也变成了“big dog”。
    // 传递给pet变量的同样是&d的一个指针副本，因为传递的是副本，所以无论是指针还是值，都可以说是浅复制；且由于传递的是指针（虽然是副本），但还是会对指向的底层变量做修改。
    d := Dog{name: "little dog"}
    var pet Pet = &d
    d.SetName("big dog")
    
    
    
    ```

  - 对于一个接口类型的变量来说，例如上面的变量`pet`，我们赋给它的值可以被叫做它的实际值（也称**动态值**），而该值的类型可以被叫做这个变量的实际类型（也称**动态类型**）。

  - 首先，由于`dog`的`SetName`方法是指针方法，所以该方法持有的接收者就是指向`dog`的指针值的副本，因而其中对接收者的`name`字段的设置就是对变量`dog`的改动。那么当`dog.SetName("monster")`执行之后，`dog`的`name`字段的值就一定是`"monster"`。

  - 为什么`dog`的`name`字段值变了，而`pet`的却没有呢？这里有一条通用的规则需要你知晓：如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个**副本**

- 接口类型值的存储方式和结构

  - 接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是`nil`，这也是它的零值。
  - 一旦它被赋予了某个实现类型的值，它的值就不再是`nil`了。不过要注意，即使我们像前面那样把`dog`的值赋给了`pet`，`pet`的值与`dog`的值也是不同的。这不仅仅是副本与原值的那种不同。
    - 这样一个变量的值其实是这个专用数据结构（iface）的一个实例，而不是我们赋给该变量的那个实际的值。所以我才说，`pet`的值与`dog`的值肯定是不同的，无论是从它们存储的内容，还是存储的结构上来看都是如此。不过，我们可以认为，这时`pet`的值中包含了`dog`值的副本。
    - **总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。**
    - 如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，在这个接口变量上仍然可以访问其方法，但无法访问其属性。使用时需要注意：如果涉及到变量属性，这些属性值均为默认值。

- 接口变量的值在什么情况下才真正为`nil`

  - ```go
    var dog1 *Dog
    fmt.Println("The first dog is nil. [wrap1]")
    dog2 := dog1
    fmt.Println("The second dog is nil. [wrap1]")
    var pet Pet = dog2
    if pet == nil {
    	fmt.Println("The pet is nil. [wrap1]")
    } else {
    	fmt.Println("The pet is not nil. [wrap1]")
    }
    ```

  - 当我们把`dog2`的值赋给变量`pet`的时候，`dog2`的值会先被复制，不过由于在这里它的值是`nil`，所以就没必要复制了。

    - 然后，Go 语言会用我上面提到的那个专用数据结构`iface`的实例包装这个`dog2`的值的副本，这里是`nil`。
    - 虽然被包装的动态值是`nil`，但是`pet`的值却不会是`nil`，因为这个动态值只是`pet`值的一部分而已。这时的`pet`的动态类型就存在了，是`*Dog`。
    - 在 Go 语言中，我们把由字面量`nil`表示的值叫做无类型的`nil`。这是真正的`nil`，因为它的类型也是`nil`的。虽然`dog2`的值是真正的`nil`，**但是当我们把这个变量赋给`pet`的时候，Go 语言会把它的类型和值放在一起考虑**。

- 怎样实现接口之间的组合

  - 接口类型间的嵌入也被称为接口的组合。

  - 接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。

  - Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。

    - 这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起

    - Go 语言标准库代码包`io`中的`ReadWriteCloser`接口和`ReadWriter`接口就是这样的例子，它们都是由若干个小接口组合而成的。以`io.ReadWriteCloser`接口为例，它是由`io.Reader`、`io.Writer`和`io.Closer`这三个接口组成的。

    - ```go
      type Animal interface {
      	ScientificName() string
      	Category() string
      }
       
      type Pet interface {
      	Animal
      	Name() string
      }
      ```



# 指针

-  Go 语言中的哪些值是不可寻址的

  - 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变的**。基本类型值的字面量也是一样，其实它们本就可以被视为常量
    - 第一个关键词：不可变的。由于 Go 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的
    - 再来看函数。函数在 Go 语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但是，这样的函数和方法都是不可寻址的。一个原因是函数就是代码，是不可变的。
      - 另一个原因是，拿到指向一段代码的指针是不安全的。此外，对函数或方法的调用结果值也是不可寻址的，这是因为它们都属于临时结果。
  - 算术操作的结果值属于一种**临时结果**。在我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。
    - 第二个关键词：临时结果。这个关键词能被用来解释很多现象。我们可以把各种对值字面量施加的表达式的求值结果都看做是临时结果。
    - 比如，对数组字面量和字典字面量的**索引**结果值，又比如，对数组字面量和切片字面量的**切片**结果值。它们都属于临时结果，都是不可寻址的。
      - 对切片字面量的切片结果值为什么却是不可寻址的？这是因为切片表达式总会返回一个新的切片值，而这个新的切片值在被赋给变量之前属于临时结果。
    - 一个需要特别注意的例外是，**对切片字面量的索引结果值是可寻址的**。因为不论怎样，每个切片值都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存地址的。
  - 再说一个例外。**我们通过对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是不可寻址的**。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。
    - 我们都知道，字典中总会有若干个哈希桶用于均匀地储存键 - 元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键 - 元素对搬运到对应的新的哈希桶中。
    - 在这种情况下，获取字典中任何元素值的指针都是无意义的，也是**不安全的**。
    - 第三个关键词：**不安全的。“不安全的”操作很可能会破坏程序的一致性，**引发不可预知的错误，从而严重影响程序的功能和稳定性。
  - 总结
    - **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
    - 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
    - 若拿到某值的指针可能会破坏程序的一致性，那么就是**不安全的**，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。
    - 如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。

- 不可寻址的值在使用上有哪些限制

  - 无法使用取址操作符`&`获取它们的指针

    - ```go
      func New(name string) Dog {
      	return Dog{name}
      }
      
      New("little pig").SetName("monster")
      ```

    - 我们可以在一个基本类型的值上调用它的指针方法，这是因为 Go 语言会自动地帮我们转译。

      - 更具体地说，对于一个`Dog`类型的变量`dog`来说，调用表达式`dog.SetName("monster")`会被自动地转译为`(&dog).SetName("monster")`，即：先取`dog`的指针值，再在该指针值上调用`SetName`方法。
      - 由于`New`函数的调用结果值是不可寻址的，所以无法对它进行取址操作。因此，上边这行链式调用会让编译器报告两个错误，一个是果，即：不能在`New("little pig")`的结果值上调用指针方法。一个是因，即：不能取得`New("little pig")`的地址。

  - 只要在**`++`或`--`**的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是**这个表达式的结果值必须是可寻址的**。这就使得针对值字面量的表达式几乎都无法被用在这里。

    - 不过这有一个例外，**虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。**

  - 与之类似的规则还有两个。**一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。**

  - 另一个是，在带有`range`子句的`for`语句中，在`range`关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。以上这三条规则我们合并起来记忆就可以了。

