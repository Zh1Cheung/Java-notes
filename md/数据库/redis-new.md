# 前言

- 相关的性能问题

  - **为了保证数据的可靠性**，Redis 需要在磁盘上读写 AOF 和 RDB，但在高并发场景里，这就会直接带来两个新问题:一个是写 AOF 和 RDB 会造成 Redis 性能抖动，另一个是 Redis 集群数据同步和实例恢复时，读 RDB 比较 慢，限制了同步和恢复速度。
  - 一个可行的解决方 案就是使用非易失内存 NVM，因为它既能保证高速的读写，又能快速持久化数据。

- 遇见的“坑”，总体来说集中在四个方面:

  - CPU 使用上的“坑”，例如数据结构的复杂度、跨 CPU 核的访问; 
  - 内存使用上的“坑”，例如主从同步和 AOF 的内存竞争; 
  - 存储持久化上的“坑”，例如在 SSD 上做快照的性能抖动;
  -  网络通信上的“坑”，例如多实例时的异常网络丢包。

- Redis 知识全景图

  - 应用维度：缓存、集群、数据结构
  - 系统维度：高性能主线、高可靠主线、高可扩展主线
    - 处理层：线程模型、主从复制、数据分片
    - 内存层：数据结构、哨兵机制、——
    - 存储层：持久化、——、负载均衡
    - 网络层：epoll网络框架、——、——

- 知识体系

  - 在应用维度上，我建议你按照两种方式学习: “**应用场景驱动**”和“**典型案例驱 动**”，一个是“面”的梳理，一个是“点”的掌握。
    - 我们知道，缓存和集群是 Redis 的两大广泛的应用场景。在这些场景中，本身就具有一条 显式的技术链。比如说，提到缓存场景，你肯定会想到缓存机制、缓存替换、缓存异常等 一连串的问题。
    - 可以用“典型案例驱动”的方式学习。我们可以重点解读一些对 Redis 的“三高”特性影响较大的使用案例，例如，多家大厂在万亿级访问量和万亿级数据量的 情况下对 Redis 的深度优化，解读这些优化实践，非常有助于你透彻地理解 Redis。而 且，你还可以梳理一些方法论，做成 Checklist，就像是一个个锦囊，之后当你遇到问题的 时候，就可以随时拿出自己的“锦囊妙计”解决问题了。
  - Redis 的问题画像
    - ![img](https://static001.geekbang.org/resource/image/70/b4/70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg)

  

  

  

# **基本架构**

- **Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value**。
- 大体来说，一个键值数据库包括了**访问框架、索引模块、操作模块和存储模块**四部分
  - PUT hello world：键值数据库网络框架接收到网络包，并按照相应的协议进行解析之后，就可以知道，客户端想写入一个键值对，并开始实际的写入流程。此时，我们会遇到一个系统设计上的问 题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢?该如何进行设计和取舍呢?我们一般把这 个问题称为 **I/O 模型设计**。不同的 I/O 模型对键值数据库的性能和可扩展性会有不同的影 响。
  - **索引的作用是让 键值数据库根据 key 找到相应 value 的存储位置，进而执行操作**。
    - 索引的类型有很多，常见的有哈希表、B+ 树、字典树等。不同的索引结构在性能、空间消 耗、并发控制等方面具有不同的特征。
    - 一般而言，内存键值数据库(例如 Redis)采用**哈希表**作为索引，很大一部分原因在于， 其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。
    - 对于 Redis 而言，很有意思的一点是，它的 value 支持多种类型，当我们通过索引找到一个 key 所对应的 value 后，仍然需要从 value 的复杂结构(例如集合和列表)中进一步找到 我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构。
    - **Redis 采用一些常见的高效索引结构作为某些 value 类型的底层数据结构，这一技术路线 为 Redis 实现高性能访问提供了良好的支撑。**
  - 对于 PUT 和 DELETE 两种操作来说，除了新写入和删除键值对，还 需要分配和释放内存。
  - Redis 也提供了持久化功能。不过，为了适应不同的业务场景，Redis 为持久化提供了诸多的执行机制和优化改进





# **数据结构**

- 重要的表现:它接收到一个键值对操作后， 能以**微秒级别**的速度找到数据，并快速完成操作。

  - 为啥 Redis 能有这么突出的表现呢?一方面，这是因为它是内存数据库， 所有操作都在**内存**上完成，内存的访问速度本身就很快。另一方面，这要归功于它的**数据结构**。

- String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、 Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会 把这四种类型称为集合类型，它们的特点是**一个键对应了一个集合的数据**。

- **键和值用什么结构组织?**

  - **为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。**
    - 因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。哈希表的最大好 处很明显，就是让我们可以用 **O(1)** 的时间复杂度来快速查找到键值对——我们只需要计算 键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素
    - 一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，**一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。**
    - **哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。**
  - 但是，如果你只是了解了哈希表的 O(1) 复杂度和快速查找特性，那么，当你往 Redis 中 写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在 的风险点，那就是**哈希表的冲突问题和 rehash 可能带来的操作阻塞。**

- **为什么哈希表操作变慢了**?

  - Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指**同一个哈希 桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。

  - **哈希冲突**可能也会越来越多，这就会导致某些哈希冲突链 过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说， 这是不太能接受的。

  - 所以，Redis 会对哈希表做 **rehash 操作**。rehash 也就是增加现有的哈希桶数量，让逐渐 增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个 桶中的冲突。

    - **为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表**

      - ```
        1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍; 2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中;
        3. 释放哈希表 1 的空间。
        ```

      - 这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都 迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据 了。

    - 为了避免这个问题，Redis 采用了**渐进式 rehash**。

      - 简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求 时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝 到哈希表 2 中;等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。
      - 这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。

- **有哪些底层数据结构?**

  -       a，string：简单动态字符串
          b，list：双向链表，压缩列表
          c，hash：压缩列表，哈希表
          d，Sorted Set：压缩列表，跳表
          e，set：哈希表，整数数组

  - 集合类型的底层数据结构主要有 5 种:整数数组、双向链表、哈 希表、压缩列表和跳表。

    - **压缩列表实际上类似于一个数组**，数组中的每一个元素都对应保存一个数据。和数组不同 的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的 偏移量和列表中的 entry 个数;
    - 压缩列表在表尾还有一个 zlend，表示列表结束。
    - 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段 的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查 找，此时的复杂度就是 O(N) 了。

  - 有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳 表在链表的基础上，**增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。O(logn)**

- **不同操作的复杂度**

  - 单元素操作是基础;
  - 范围操作非常耗时;
  - 统计操作（是指**集合类型对集合中所有元素个数的记录**）通常高效;
    - 例如 LLEN 和 SCARD。这 类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数 据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。
  - 例外情况只有几个。
    - 是指某些数据结构的特殊记录，例如**压缩列表和双向链表都会记录表头 和表尾的偏移量**。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操 作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂 度也只有 O(1)，可以实现快速操作。

- 整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它 们作为底层数据结构呢?

  - **内存利用率**，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。
  - **数组对CPU高速缓存支持更友好**，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

- 



























