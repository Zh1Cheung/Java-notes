# **渲染流程**

- **DOM 生成、样式计算**和**布局**

  - 在 HTML 页面内容被提交给渲染引擎 后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM;
  - 然后根据 CSS 样式表，计算出 DOM 树所有节点的样式;
  - 接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

- **分层**

  - 因为页面中有很多复杂的效果，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**。
    - 渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形 成了最终的页面
    - 通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么 这个节点就从属于父节点的图层**。
  - 通常满足下面两点中任 意一点的元素就可以被提升为单独的一个图层。
    - **第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**
      - 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等， 都拥有层叠上下文属性。
    - **第二点，需要剪裁(clip)的地方也会被创建为图层。**
      - 把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所 显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字 内容的一部分用于显示在 div 区域。
      - 出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动 条也会被提升为单独的层。

- **图层绘制**

  - 渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，然后再 把这些指令按照顺序组成一个待绘制列表
  - 你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘 制列表

- **栅格化(raster)操作**

  - 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的**合成线程**来完成的。
  - 当图层的绘制列表准备好之后，主线程会把该绘制列表**提交(commit)**给合成线程
    - 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分 叫做**视口**(viewport)。
    - 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底 部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图 层内容的话，就会产生太大的开销，而且也没有必要。
    - 基于这个原因，**合成线程会将图层划分为图块(tile)**，这些图块的大小通常是 256x256 或者 512x512。
  - 然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图**。
  - 渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块 的位图，并保存在 GPU 的内存中。

- **合成和显示**

  - 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程。
  - 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后 根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
  - 到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器 就会显示出漂亮的页面了。

- 一个完整的渲染流程大致可总结为如下

  - 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。

  - 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的

    样式。

  - 创建**布局树**，并计算元素的布局信息。

  - 对布局树进行分层，并生成**分层树**。

  - 为每个图层生成**绘制列表**，并将其提交到合成线程。

  - 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。

  - 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。

  - 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。





# **变量提升**

- 三个结论

  - 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
  - 在一个**变量**定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。
  - 在一个**函数**定义之前使用它，不会出错，且函数能正确执行。

- 变量提升

  - JavaScript 中的**声明** 和**赋值**。

    - **变量**的声明和赋值，**函数**的声明和赋值

    - ```javascript
       var myname // 声明部分
       myname = 'gek' // 赋值部分
       var myname = 'gek' // 变量的声明和赋值
        
      // 函数声明
      function foo(){
       console.log('foo') 
      }
      // 函数的声明和赋值
      var bar = function(){  
        console.log('bar') 
      }
      ```

  - 所谓的变量提升，**是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值**，这个默认值就是我们熟悉的 undefined。

- JavaScript 代码的执行流程

  - **实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。
  - 一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，**编译**完成之后，才会进入**执行**阶 段。
  - 输入一段代码，经过编译后，会生成两部分内容:**执行上下文 (Execution context)和可执行代码**。
    - **编译阶段**
      - **执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个 函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。
      - 在执行上下文中存在一个**变量环境的对象** (Viriable Environment)，该对象中保存了变量提升的内容
      - 接下来 JavaScript 引擎会把声明以外的代码编译为字节码
    - **执行阶段**
      - JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。

- 代码中出现相同的变量或者函数怎么办

  - 完整执行流程
    - **首先是编译阶段**，**第二个 showName 函数会将第一个 showName 函数覆 盖掉**。这样变量环境中就只存在第二个 showName 函数了。
    - **接下来是执行阶段**。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数。
  - **一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**







# **调用栈**

- 到底什么样的代码才算符合规范
  - 哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况:
    - 当 JavaScript 执行**全局代码**的时候，会编译全局代码并创建全局执行上下文，而且在 整个页面的生存周期内，全局执行上下文只有一份。
    - 当**调用一个函数**的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况 下，函数执行结束之后，创建的函数执行上下文会被销毁。
    - 当使用 **eval 函数**的时候，eval 的代码也会被编译，并创建执行上下文。
- **调用栈就是用来管理函数调用关系的一种数据结构**。
  - 函数调用
    - 先是创建了一个 add 函数，接着在代码的最下面又调用了该函数。
      - 在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含 了声明的函数和变量
      - 执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这 是一个函数调用，那么将执行以下操作
        - 首先，从**全局执行上下文**中，取出 add 函数代码。
        -  其次，对 add 函数的这段代码进行编译，并创建**该函数的执行上下文**和**可执行代码**。
        -  最后，执行代码，输出结果。
    - 就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。
  - 栈结构
    - **JavaScript 引擎正是利用栈的这种结构来管理执行上下文的**。在执行上下文创建好后， JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行 上下文栈**，又称**调用栈**。
    - **调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多 个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关 系。
- **在开发中，如何利用好调用栈**
  - 点击“Source”标签，选择 JavaScript 代码的页面，加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况。栈的最底部是 anonymous，也就是全局的函数入口。
  - 除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系
-  栈溢出
  - 当入栈的执行上下文超过一定数目，JavaScript 引 擎就会报错，我们把这种错误叫做**栈溢出**。
  - 可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调 用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任 务。







# **块级作用域**

- **正是由于 JavaScript 存在变量提升这种特性， 从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷**。

  - 虽然 ECMAScript6(以下简称 ES6)已经通过引入块级作用域并配合 let、const 关键字， 来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长 一段时间内还会继续存在。

- 作用域

  - 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，**作用域 就是变量与函数的可访问范围**，即作用域控制着变量和函数的可见性和生命周期。
  - 块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句， 甚至单独的一个{}都可以被看作是一个块级作用域。

- **变量提升所带来的问题**

  - 变量容易在不被察觉的情况下被覆盖掉

  - 本应销毁的变量没有被销毁

    - ```javascript
      // 在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。
      function foo(){
       for (var i = 0; i < 7; i++) { 
       }
       console.log(i);
      }
       foo()
      ```

- **ES6** **是如何解决变量提升带来的缺陷**

  - **ES6 引入了 let 和const 关键字**，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。
    - 使用 let 关键字声明的变量是可以被改变 的，而使用 const 声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级 作用域。

- **JavaScript** **是如何支持块级作用域的**

  - **站在执行上下文的角度**
  - 代码的执行流程
    - **第一步是编译并创建执行上下文**
      - 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
      - 通过 let 声明的变量，在编译阶段会被存放到**词法环境(Lexical Environment)**中。 
      - 在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中。
    - 接下来，**第二步继续执行代码**，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在 词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，**比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。**
    - **再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了**，具体查找方式是:沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继 续在变量环境中查找。

  

  

  



# **作用域链和闭包**

- **作用域链**

  - ```javascript
    function bar() {
     console.log(myName) 
    }
     function foo() {
     var myName = " abc "
     bar()
    }
     var myName = " qaz " 
    foo()
    
    ```

  - 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为**outer**。

    - 当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找

  - bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如 果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文 中查找。我们把这个查找的链条就称为**作用域链**。

- **词法作用域**

  - 词法作用域就是指作用域是**由代码中函数声明的位置来决定的**，所以词法作用域是静态的作 用域，通过它就能够预测代码在执行过程中如何查找标识符。
  - foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下 文?
    - foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。

- **块级作用域中的变量查找**

  - 在编写代码的时候，如果你使用了一个在当前作用域中不存在的 变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量。

- **闭包**

  - ```javascript
    function foo() {
    	var myName = " abc " 
    	let test1 = 1
    	const test2 = 2
    	var innerBar = { 
    		getName:function(){
    			console.log(test1)
      	  return myName
    		},
    		setName:function(newName){ 
    			myName = newName
    	}
      return innerBar
    } 
    
    var bar = foo()
    bar.setName(" qaz ")
    bar.getName()
    console.log(bar.getName())
    ```

  - foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两 个变量依然保存在内存中。

  - **根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量**，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结 束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。

  - 在 JavaScript 中，根据词法作用域的 规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个 内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。**比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。**

- **闭包是怎么回收的**

  - 通常，如果引用闭包的函数是一个**全局变量**，那么闭包会一直存在直到页面关闭;但如果这 个闭包以后不再使用的话，就会造成内存泄漏。
  - 如果引用闭包的函数是个**局部变量**，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收 时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。
  - 所以在使用闭包的时候，你要尽量注意一个原则:**如果该闭包会一直使用，那么它可以作为 全局变量而存在;但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一 个局部变量**。







# **this**

- **在对象内部的方法中使用对象内部的属性是一 个非常普遍的需求**——**this 机制**

- **JavaScript** **中的** **this** **是什么**

  - 执行上下文中 包含了变量环境、词法环境、外部环境，但其实还有一个 this 没有提及
  - **this 是和执行上下文绑定的**，也就是说每个执行上下文中都有一个 this

- **全局执行上下文中的** **this**

  - 全局执行上下文中的 this 是指向window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

- **函数执行上下文中的** **this**

  - 我们在 foo 函数内部打印出来 this 值，执行这段代码，打印出来的也是 window 对象，这 说明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。

- 能不能设置执行上下文中的 this 来指向其他对象呢?通常情况下，有下面三种方式来设置函数执行上下文中的 this 值。

  - **通过函数的** **call** **方法设置**

    - 你可以通过函数的**call**方法来设置函数执行上下文的 this 指向

    - ```javascript
      let bar = {
      	myName : " aaa ", 
         test1 : 1
      }
      function foo(){
      this.myName = " ccc " 
      }
      foo.call(bar)
      console.log(bar)
      console.log(myName)
      ```

  - **通过对象调用方法设置**

    - ```javascript
      var myObj = {
      name : " aaa ", 
        showThis: function(){
          console.log(this)
      	}
      }
      myObj.showThis()
      ```

    - 使用对象来调用其内部的一个方法，该方法的 this 是**指向对象本身**的。

  - **通过构造函数中设置**

    - ```javascript
      function CreateObj(){
      	this.name = " aaa " 
      }
      var myObj = new CreateObj()
      ```

    - 其实，当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事:

      - 首先创建了一个空对象 tempObj;
      - 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象;
      - 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象;
      - 最后返回 tempObj 对象。

- this 的设计缺陷以及应对方案

  - **嵌套函数中的** **this** **不会从外层函数中继承**

    - ```javascript
      // 函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象
      var myObj = {
      	name : " aaa ",
        showThis: function(){
      		console.log(this)
      		function bar(){console.log(this)}}
       		bar()
       }
      }
      myObj.showThis()
      ```

    - **你可以通过小技巧来解决这个问题**，比如在 showThis 函数中**声明一个变量 self 用来 保存 this**

    - **你也可以使用 ES6 中的箭头函数来解决这个问题**

      - ```javascript
        var myObj = {
        name : " aaa ", 
          showThis: function(){
        		console.log(this) 
            var bar = ()=>{
        			this.name = " bbb " 
              console.log(this)
        		bar() 
          }
        }
        myObj.showThis() 
        console.log(myObj.name) 
        console.log(window.name)
        ```

  - **普通函数中的** **this** **默认指向全局对象** **window**

    - 如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。
    - 这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个 函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。





# **栈空间和堆空间**

- 





















































