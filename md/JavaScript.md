# **渲染流程**

- **DOM 生成、样式计算**和**布局**

  - 在 HTML 页面内容被提交给渲染引擎 后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM;
  - 然后根据 CSS 样式表，计算出 DOM 树所有节点的样式;
  - 接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

- **分层**

  - 因为页面中有很多复杂的效果，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**。
    - 渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形 成了最终的页面
    - 通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么 这个节点就从属于父节点的图层**。
  - 通常满足下面两点中任 意一点的元素就可以被提升为单独的一个图层。
    - **第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**
      - 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等， 都拥有层叠上下文属性。
    - **第二点，需要剪裁(clip)的地方也会被创建为图层。**
      - 把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所 显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字 内容的一部分用于显示在 div 区域。
      - 出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动 条也会被提升为单独的层。

- **图层绘制**

  - 渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，然后再 把这些指令按照顺序组成一个待绘制列表
  - 你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘 制列表

- **栅格化(raster)操作**

  - 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的**合成线程**来完成的。
  - 当图层的绘制列表准备好之后，主线程会把该绘制列表**提交(commit)**给合成线程
    - 通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分 叫做**视口**(viewport)。
    - 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底 部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图 层内容的话，就会产生太大的开销，而且也没有必要。
    - 基于这个原因，**合成线程会将图层划分为图块(tile)**，这些图块的大小通常是 256x256 或者 512x512。
  - 然后**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图**。
  - 渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块 的位图，并保存在 GPU 的内存中。

- **合成和显示**

  - 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”， 然后将该命令提交给浏览器进程。
  - 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后 根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
  - 到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器 就会显示出漂亮的页面了。

- 一个完整的渲染流程大致可总结为如下

  - 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。

  - 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的

    样式。

  - 创建**布局树**，并计算元素的布局信息。

  - 对布局树进行分层，并生成**分层树**。

  - 为每个图层生成**绘制列表**，并将其提交到合成线程。

  - 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。

  - 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。

  - 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。





# **变量提升**

- 三个结论

  - 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
  - 在一个**变量**定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。
  - 在一个**函数**定义之前使用它，不会出错，且函数能正确执行。

- 变量提升

  - JavaScript 中的**声明** 和**赋值**。

    - **变量**的声明和赋值，**函数**的声明和赋值

    - ```javascript
       var myname // 声明部分
       myname = 'gek' // 赋值部分
       var myname = 'gek' // 变量的声明和赋值
      
      // 函数声明
      function foo(){
       console.log('foo') 
      }
      // 函数的声明和赋值
      var bar = function(){  
        console.log('bar') 
      }
      ```

  - 所谓的变量提升，**是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值**，这个默认值就是我们熟悉的 undefined。

- JavaScript 代码的执行流程

  - **实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。
  - 一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，**编译**完成之后，才会进入**执行**阶 段。
  - 输入一段代码，经过编译后，会生成两部分内容:**执行上下文 (Execution context)和可执行代码**。
    - **编译阶段**
      - **执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个 函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。
      - 在执行上下文中存在一个**变量环境的对象** (Viriable Environment)，该对象中保存了变量提升的内容
      - 接下来 JavaScript 引擎会把声明以外的代码编译为字节码
    - **执行阶段**
      - JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。

- 代码中出现相同的变量或者函数怎么办

  - 完整执行流程
    - **首先是编译阶段**，**第二个 showName 函数会将第一个 showName 函数覆 盖掉**。这样变量环境中就只存在第二个 showName 函数了。
    - **接下来是执行阶段**。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数。
  - **一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数**







# **调用栈**

- 到底什么样的代码才算符合规范
  - 哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况:
    - 当 JavaScript 执行**全局代码**的时候，会编译全局代码并创建全局执行上下文，而且在 整个页面的生存周期内，全局执行上下文只有一份。
    - 当**调用一个函数**的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况 下，函数执行结束之后，创建的函数执行上下文会被销毁。
    - 当使用 **eval 函数**的时候，eval 的代码也会被编译，并创建执行上下文。
- **调用栈就是用来管理函数调用关系的一种数据结构**。
  - 函数调用
    - 先是创建了一个 add 函数，接着在代码的最下面又调用了该函数。
      - 在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含 了声明的函数和变量
      - 执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这 是一个函数调用，那么将执行以下操作
        - 首先，从**全局执行上下文**中，取出 add 函数代码。
        -  其次，对 add 函数的这段代码进行编译，并创建**该函数的执行上下文**和**可执行代码**。
        -  最后，执行代码，输出结果。
    - 就这样，当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。
  - 栈结构
    - **JavaScript 引擎正是利用栈的这种结构来管理执行上下文的**。在执行上下文创建好后， JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为**执行 上下文栈**，又称**调用栈**。
    - **调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多 个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关 系。
- **在开发中，如何利用好调用栈**
  - 点击“Source”标签，选择 JavaScript 代码的页面，加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况。栈的最底部是 anonymous，也就是全局的函数入口。
  - 除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系
-  栈溢出
  - 当入栈的执行上下文超过一定数目，JavaScript 引 擎就会报错，我们把这种错误叫做**栈溢出**。
  - 可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调 用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任 务。







# **块级作用域**

- **正是由于 JavaScript 存在变量提升这种特性， 从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷**。

  - 虽然 ECMAScript6(以下简称 ES6)已经通过引入块级作用域并配合 let、const 关键字， 来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长 一段时间内还会继续存在。

- 作用域

  - 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，**作用域 就是变量与函数的可访问范围**，即作用域控制着变量和函数的可见性和生命周期。
  - 块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句， 甚至单独的一个{}都可以被看作是一个块级作用域。

- **变量提升所带来的问题**

  - 变量容易在不被察觉的情况下被覆盖掉

  - 本应销毁的变量没有被销毁

    - ```javascript
      // 在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。
      function foo(){
       for (var i = 0; i < 7; i++) { 
       }
       console.log(i);
      }
       foo()
      ```

- **ES6** **是如何解决变量提升带来的缺陷**

  - **ES6 引入了 let 和const 关键字**，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。
    - 使用 let 关键字声明的变量是可以被改变 的，而使用 const 声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级 作用域。

- **JavaScript** **是如何支持块级作用域的**

  - **站在执行上下文的角度**
  - 代码的执行流程
    - **第一步是编译并创建执行上下文**
      - 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
      - 通过 let 声明的变量，在编译阶段会被存放到**词法环境(Lexical Environment)**中。 
      - 在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中。
    - 接下来，**第二步继续执行代码**，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在 词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，**比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。**
    - **再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了**，具体查找方式是:沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继 续在变量环境中查找。

  

  

  





























