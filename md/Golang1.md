# go语句及其执行规则

- 不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。
  - 通道（也就是 channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的 goroutine 之间传递数据。那么 goroutine 到底代表着什么呢？
  - **简单来说，goroutine 代表着并发编程模型中的用户级线程**
    - 在 Go 程序当中，**Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。**
    - 而**对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程**。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。
    - 这带来了很多**优势**，比如，因为它们的创建和销毁并不用通过操作系统去做，所以**速度会很快**，又比如，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很**灵活**。
    - 但是，劣势也是有的，**最明显也最重要的一个劣势就是复杂**。如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳。
    - 但是，如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。
- **Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，还拥有强大的用于调度 goroutine、对接系统级线程的调度器。**
  - 这个调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）。
  - 其中的 M 指代的就是系统级线程。而 P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介。

-  什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同

  - ```go
    // 这个命令源码文件被执行后会打印出什么内容
    // 绝大多数情况都会是“不会有任何内容被打印出来”。
    func main() {
    	for i := 0; i < 10; i++ {
    		go func() {
    			fmt.Println(i)
    		}()
    	}
    }
    ```

  - 与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine。**这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作**。

    - **每条`go`语句一般都会携带一个函数调用，这个被调用的函数常常被称为`go`函数。而主 goroutine 的`go`函数就是那个作为程序入口的`main`函数**
    - **一定要注意，`go`函数真正被执行的时间，总会与其所属的`go`语句被执行的时间不同。**当程序执行到一条`go`语句的时候，Go 语言的运行时系统，**会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine）**，它只有在找不到空闲 G 的情况下才会去创建一个新的 G。
    - 这也是为什么我总会说“启用”一个 goroutine，而不说“创建”一个 goroutine 的原因。已存在的 goroutine 总是会被优先复用。然而，创建 G 的成本也是非常低的。
    - 在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去**包装**当前的那个`go`函数（或者说该函数中的那些代码），然后再把这个 G 追加到某个存放可运行的 G 的**队列**中。
      - 这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。
      - 因此，`go`函数的执行时间总是会明显滞后于它所属的`go`语句的执行时间。当然了，这里所说的“明显滞后”是对于计算机的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。

  - 请记住，只要`go`语句本身执行完毕，Go 程序完全不会等待`go`函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。

    - 这里“后边的语句”指的一般是`for`语句中的下一个迭代。
    - 请注意，`go`函数中的那个对`fmt.Println`函数的调用是以`for`语句中的变量`i`作为参数的。你可以想象一下，如果当`for`语句执行完毕的时候，这些`go`函数都还没有执行，那么它们引用的变量`i`的值将会是什么
      - 主 goroutine 有关的重要特性，即：**一旦主 goroutine 中的代码（也就是`main`函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行**。
      - 如此一来，如果在 Go 程序结束的那一刻，还有 goroutine 未得到运行机会，那么它们就真的没有运行机会了，它们中的代码也就不会被执行了。

- 在go语句执行后，Go运行时系统会把对应的go函数装进新启用的goroutine中，随后调度执行。因为这个调度是不保证先后顺序的，所以这些go函数的执行在默认情况下也是乱序的。

- 怎样才能让主 goroutine 等待其他 goroutine

  - 最简单粗暴的办法就是让主 goroutine“小睡”一会儿。

    - ```go
      for i := 0; i < 10; i++ {
      	go func() {
      		fmt.Println(i)
      	}()
      }
      time.Sleep(time.Millisecond * 500)
      ```

  - 你可能会想到，既然不容易预估时间，那我们就让其他的 goroutine 在运行完毕的时候告诉我们好了。

    - ```go
      func main() {
      	num := 10
        // 在声明通道sign的时候是以chan struct{}作为其类型的。其中的类型字面量struct{}有些类似于空接口类型interface{}，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。
      	sign := make(chan struct{}, num)
      
      	for i := 0; i < num; i++ {
      		go func() {
      			fmt.Println(i)
            // 注意，struct{}类型值的表示法只有一个，即：struct{}{}。
            // 当我们仅仅把通道当作传递某种简单信号的介质的时候，用struct{}作为其元素类型是再好不过的了。
      			sign <- struct{}{}
      		}()
      	}
      
      	// 办法1。
      	//time.Sleep(time.Millisecond * 500)
      
      	// 办法2。
      	for j := 0; j < num; j++ {
      		<-sign
      	}
      }
      ```

  - 如果你知道标准库中的代码包`sync`的话，那么可能会想到`sync.WaitGroup`类型。

- 怎样让我们启用的多个 goroutine 按照既定的顺序运行

  - 在`go`语句被执行时，我们传给`go`函数的参数`i`会先被求值，如此就得到了当次迭代的序号。之后，无论`go`函数会在什么时候执行，这个参数值都不会变。也就是说，`go`函数中调用的`fmt.Println`函数打印的一定会是那个当次迭代的序号。

  - ```go
    func main() {
    	var count uint32
      /*
      
      trigger函数会不断地获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就立即调用fn代表的函数，然后把count变量的值加1，最后显式地退出当前的循环。否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代。
    
    注意，我操作变量count的时候使用的都是原子操作。这是由于trigger函数会被多个 goroutine 并发地调用，所以它用到的非本地变量count，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并发安全性。
    
    所以，我们总是应该对这样的操作加以保护，在sync/atomic包中声明了很多用于原子操作的函数。
    
    另外，由于我选用的原子操作函数对被操作的数值的类型有约束，所以我才对count以及相关的变量和参数的类型进行了统一的变更（由int变为了uint32）。
    
      */
    	trigger := func(i uint32, fn func()) {
    		for {
    			if n := atomic.LoadUint32(&count); n == i {
    				fn()
    				atomic.AddUint32(&count, 1)
    				break
    			}
    			time.Sleep(time.Nanosecond)
    		}
    	}
    	for i := uint32(0); i < 10; i++ {
    		go func(i uint32) {
    			fn := func() {
    				fmt.Println(i)
    			}
    			trigger(i, fn)
    		}(i)
    	}
      /*
      
      如果依然想让主 goroutine 最后一个运行完毕，所以还需要加一行代码。不过既然有了trigger函数，我就没有再使用通道。
      调用trigger函数完全可以达到相同的效果。由于当所有我手动启用的 goroutine 都运行完毕之后，count的值一定会是10，所以我就把10作为了第一个参数值。又由于我并不想打印这个10，所以我把一个什么都不做的函数作为了第二个参数值。
      */
    	trigger(10, func() {})
    }
    ```

  - 纵观`count`变量、`trigger`函数以及改造后的`for`语句和`go`函数，我要做的是，**让`count`变量成为一个信号，它的值总是下一个可以调用打印函数的`go`函数的序号。**

  - **这个序号其实就是启用 goroutine 时，那个当次迭代的序号。也正因为如此，`go`函数实际的执行顺序才会与`go`语句的执行顺序完全一致。**此外，这里的`trigger`函数实现了一种自旋（spinning）。除非发现条件已满足，否则它会不断地进行检查。































