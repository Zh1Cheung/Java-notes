# go语句及其执行规则

- 不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。
  - 通道（也就是 channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的 goroutine 之间传递数据。那么 goroutine 到底代表着什么呢？
  - **简单来说，goroutine 代表着并发编程模型中的用户级线程**
    - 在 Go 程序当中，**Go 语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。**
    - 而**对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程**。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。
    - 这带来了很多**优势**，比如，因为它们的创建和销毁并不用通过操作系统去做，所以**速度会很快**，又比如，由于不用等着操作系统去调度它们的运行，所以往往会很容易控制并且可以很**灵活**。
    - 但是，劣势也是有的，**最明显也最重要的一个劣势就是复杂**。如果我们只使用了系统级线程，那么我们只要指明需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他的一切具体实现都会由操作系统代劳。
    - 但是，如果使用用户级线程，我们就不得不既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。
- **Go 语言不但有着独特的并发编程模型，以及用户级线程 goroutine，还拥有强大的用于调度 goroutine、对接系统级线程的调度器。**
  - 这个调度器是 Go 语言运行时系统的重要组成部分，它主要负责统筹调配 Go 并发编程模型中的三个主要元素，即：G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写）。
  - 其中的 M 指代的就是系统级线程。而 P 指的是一种可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接，并得到真正运行的中介。

-  什么是主 goroutine，它与我们启用的其他 goroutine 有什么不同

  - ```go
    // 这个命令源码文件被执行后会打印出什么内容
    // 绝大多数情况都会是“不会有任何内容被打印出来”。
    func main() {
    	for i := 0; i < 10; i++ {
    		go func() {
    			fmt.Println(i)
    		}()
    	}
    }
    ```

  - 与一个进程总会有一个主线程类似，每一个独立的 Go 程序在运行时也总会有一个主 goroutine。**这个主 goroutine 会在 Go 程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作**。

    - **每条`go`语句一般都会携带一个函数调用，这个被调用的函数常常被称为`go`函数。而主 goroutine 的`go`函数就是那个作为程序入口的`main`函数**
    - **一定要注意，`go`函数真正被执行的时间，总会与其所属的`go`语句被执行的时间不同。**当程序执行到一条`go`语句的时候，Go 语言的运行时系统，**会先试图从某个存放空闲的 G 的队列中获取一个 G（也就是 goroutine）**，它只有在找不到空闲 G 的情况下才会去创建一个新的 G。
    - 这也是为什么我总会说“启用”一个 goroutine，而不说“创建”一个 goroutine 的原因。已存在的 goroutine 总是会被优先复用。然而，创建 G 的成本也是非常低的。
    - 在拿到了一个空闲的 G 之后，Go 语言运行时系统会用这个 G 去**包装**当前的那个`go`函数（或者说该函数中的那些代码），然后再把这个 G 追加到某个存放可运行的 G 的**队列**中。
      - 这类队列中的 G 总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。
      - 因此，`go`函数的执行时间总是会明显滞后于它所属的`go`语句的执行时间。当然了，这里所说的“明显滞后”是对于计算机的 CPU 时钟和 Go 程序来说的。我们在大多数时候都不会有明显的感觉。

  - 请记住，只要`go`语句本身执行完毕，Go 程序完全不会等待`go`函数的执行，它会立刻去执行后边的语句。这就是所谓的异步并发地执行。

    - 这里“后边的语句”指的一般是`for`语句中的下一个迭代。
    - 请注意，`go`函数中的那个对`fmt.Println`函数的调用是以`for`语句中的变量`i`作为参数的。你可以想象一下，如果当`for`语句执行完毕的时候，这些`go`函数都还没有执行，那么它们引用的变量`i`的值将会是什么
      - 主 goroutine 有关的重要特性，即：**一旦主 goroutine 中的代码（也就是`main`函数中的那些代码）执行完毕，当前的 Go 程序就会结束运行**。
      - 如此一来，如果在 Go 程序结束的那一刻，还有 goroutine 未得到运行机会，那么它们就真的没有运行机会了，它们中的代码也就不会被执行了。

- 在go语句执行后，Go运行时系统会把对应的go函数装进新启用的goroutine中，随后调度执行。因为这个调度是不保证先后顺序的，所以这些go函数的执行在默认情况下也是乱序的。

- 怎样才能让主 goroutine 等待其他 goroutine

  - 最简单粗暴的办法就是让主 goroutine“小睡”一会儿。

    - ```go
      for i := 0; i < 10; i++ {
      	go func() {
      		fmt.Println(i)
      	}()
      }
      time.Sleep(time.Millisecond * 500)
      ```

  - 你可能会想到，既然不容易预估时间，那我们就让其他的 goroutine 在运行完毕的时候告诉我们好了。

    - ```go
      func main() {
      	num := 10
        // 在声明通道sign的时候是以chan struct{}作为其类型的。其中的类型字面量struct{}有些类似于空接口类型interface{}，它代表了既不包含任何字段也不拥有任何方法的空结构体类型。
      	sign := make(chan struct{}, num)
      
      	for i := 0; i < num; i++ {
      		go func() {
      			fmt.Println(i)
            // 注意，struct{}类型值的表示法只有一个，即：struct{}{}。
            // 当我们仅仅把通道当作传递某种简单信号的介质的时候，用struct{}作为其元素类型是再好不过的了。
      			sign <- struct{}{}
      		}()
      	}
      
      	// 办法1。
      	//time.Sleep(time.Millisecond * 500)
      
      	// 办法2。
      	for j := 0; j < num; j++ {
      		<-sign
      	}
      }
      ```

  - 如果你知道标准库中的代码包`sync`的话，那么可能会想到`sync.WaitGroup`类型。

- 怎样让我们启用的多个 goroutine 按照既定的顺序运行

  - 在`go`语句被执行时，我们传给`go`函数的参数`i`会先被求值，如此就得到了当次迭代的序号。之后，无论`go`函数会在什么时候执行，这个参数值都不会变。也就是说，`go`函数中调用的`fmt.Println`函数打印的一定会是那个当次迭代的序号。

  - ```go
    func main() {
    	var count uint32
      /*
      
      trigger函数会不断地获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就立即调用fn代表的函数，然后把count变量的值加1，最后显式地退出当前的循环。否则，我们就先让当前的 goroutine“睡眠”一个纳秒再进入下一个迭代。
    
    注意，我操作变量count的时候使用的都是原子操作。这是由于trigger函数会被多个 goroutine 并发地调用，所以它用到的非本地变量count，就被多个用户级线程共用了。因此，对它的操作就产生了竞态条件（race condition），破坏了程序的并发安全性。
    
    所以，我们总是应该对这样的操作加以保护，在sync/atomic包中声明了很多用于原子操作的函数。
    
    另外，由于我选用的原子操作函数对被操作的数值的类型有约束，所以我才对count以及相关的变量和参数的类型进行了统一的变更（由int变为了uint32）。
    
      */
    	trigger := func(i uint32, fn func()) {
    		for {
    			if n := atomic.LoadUint32(&count); n == i {
    				fn()
    				atomic.AddUint32(&count, 1)
    				break
    			}
    			time.Sleep(time.Nanosecond)
    		}
    	}
    	for i := uint32(0); i < 10; i++ {
    		go func(i uint32) {
    			fn := func() {
    				fmt.Println(i)
    			}
    			trigger(i, fn)
    		}(i)
    	}
      /*
      
      如果依然想让主 goroutine 最后一个运行完毕，所以还需要加一行代码。不过既然有了trigger函数，我就没有再使用通道。
      调用trigger函数完全可以达到相同的效果。由于当所有我手动启用的 goroutine 都运行完毕之后，count的值一定会是10，所以我就把10作为了第一个参数值。又由于我并不想打印这个10，所以我把一个什么都不做的函数作为了第二个参数值。
      */
    	trigger(10, func() {})
    }
    ```

  - 纵观`count`变量、`trigger`函数以及改造后的`for`语句和`go`函数，我要做的是，**让`count`变量成为一个信号，它的值总是下一个可以调用打印函数的`go`函数的序号。**

  - **这个序号其实就是启用 goroutine 时，那个当次迭代的序号。也正因为如此，`go`函数实际的执行顺序才会与`go`语句的执行顺序完全一致。**此外，这里的`trigger`函数实现了一种自旋（spinning）。除非发现条件已满足，否则它会不断地进行检查。





# 错误处理

- 对于具体错误的判断，Go 语言中都有哪些惯用法

  - 这个问题还可以换一种问法，即：怎样判断一个错误值具体代表的是哪一类错误？

  - 对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型`switch`语句来判断；

    - 就拿`os`包中的几个代表错误的类型`os.PathError`、`os.LinkError`、`os.SyscallError`和`os/exec.Error`来说，它们的指针类型都是`error`接口的实现类型，同时它们也都包含了一个名叫`Err`，类型为`error`接口类型的代表潜在错误的字段。

    - ```go
      func underlyingError(err error) error {
      	switch err := err.(type) {
      	case *os.PathError:
      		return err.Err
      	case *os.LinkError:
      		return err.Err
      	case *os.SyscallError:
      		return err.Err
      	case *exec.Error:
      		return err.Err
      	}
      	return err
      }
      ```

    - 我们还拿`os`包来说，其中不少的错误值都是通过调用`errors.New`函数来初始化的，比如：`os.ErrClosed`、`os.ErrInvalid`以及`os.ErrPermission`，等等。

    - 如果我们在操作文件系统的时候得到了一个错误值，并且知道该值的潜在错误值肯定是上述值中的某一个，那么就可以用普通的`switch`语句去做判断，当然了，用`if`语句和判等操作符也是可以的。

    - ```go
      printError := func(i int, err error) {
      	if err == nil {
      		fmt.Println("nil error")
      		return
      	}
      	err = underlyingError(err)
      	switch err {
      	case os.ErrClosed:
      		fmt.Printf("error(closed)[%d]: %s\n", i, err)
      	case os.ErrInvalid:
      		fmt.Printf("error(invalid)[%d]: %s\n", i, err)
      	case os.ErrPermission:
      		fmt.Printf("error(permission)[%d]: %s\n", i, err)
      	}
      }
      ```

    - 虽然我不知道这些错误值的类型的范围，但却知道它们或它们的潜在错误值一定是某个已经在`os`包中定义的值。

    - **所以，我先用`underlyingError`函数得到它们的潜在错误值**，当然也可能只得到原错误值而已。然后，我用`switch`语句**对错误值进行判等操作，三个`case`子句分别对应我刚刚提到的那三个已存在于`os`包中的错误值。**如此一来，我就能分辨出**具体错误**了。

  - 对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；

  - 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。

  - 好在我们总是能通过错误值的`Error`方法，拿到它的错误信息。其实`os`包中就有做这种判断的函数，比如：`os.IsExist`、`os.IsNotExist`和`os.IsPermission`。

- 怎样根据实际情况给予恰当的错误值

  - 构建错误值体系的基本方式有两种，即：**创建立体的错误类型体系和创建扁平的错误值列表。**
    - 由于在 Go 语言中实现接口是非侵入式的，所以我们可以做得很灵活。比如，在标准库的`net`代码包中，有一个名为`Error`的接口类型。它算是内建接口类型`error`的一个扩展接口，因为`error`是`net.Error`的嵌入接口。
    - 用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。这是 Go 语言标准库给予我们的优秀范本，非常有借鉴意义。
    - `net`包中有很多错误类型都实现了`net.Error`接口，比如：
      1. `*net.OpError`；
      2. `*net.AddrError`；
      3. `net.UnknownNetworkError`等等。
    - 你可以把这些错误类型想象成一棵**树**，内建接口`error`就是树的根，而`net.Error`接口就是一个在根上延伸的第一级非叶子节点。
    - 同时，你也可以把这看做是一种**多层分类**的手段。当`net`包的使用者拿到一个错误值的时候，可以先判断它是否是`net.Error`类型的，也就是说该值是否代表了一个网络相关的错误。
    - 如果是，那么我们还可以再**进一步判断它的类型是哪一个更具体的错误类型**，这样就能知道这个网络相关的错误具体是由于操作不当引起的，还是因为网络地址问题引起的，又或是由于网络协议不正确引起的。
    - 不过要注意，**如果你不想让包外代码改动你返回的错误值的话，一定要小写其中字段的名称首字母**。你可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如**编写一个可以返回包级私有的`err`字段值的公开方法`Err`**。
    - **之所以说错误类型体系是立体的，是因为从整体上看它往往呈现出树形的结构。**通过接口间的嵌套以及接口的实现，我们就可以构建出一棵错误类型树。
      - 通过这棵树，使用者就可以一步步地确定错误值的种类了。另外，为了追根溯源的需要，我们还可以在错误类型中，统一安放一个可以代表潜在错误的字段。这叫做链式的错误关联，可以帮助使用者找到错误的根源。
  - 相比于立体的错误类型体系，**扁平的错误值列表**就要简单得多了，**它其实就是若干个名称不同但类型相同的错误值集合。**当我们只是想预先创建一些代表已知错误的错误值时候，用这种扁平化的方式就很恰当了。
    - 不过，由于`error`是接口类型，所以**通过`errors.New`函数生成的错误值只能被赋给变量**，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其**访问权限只能是公开的**。
    - 这就带来了一个问题，如果有恶意代码改变了这些公开变量的值，那么程序的功能就必然会受到影响。
      - 这里有两个解决方案。**第一个方案是，先私有化此类变量**，也就是说，让它们的名称首字母变成小写，**然后编写公开的用于获取错误值以及用于判等错误值的函数。**
      - 比如，对于错误值`os.ErrClosed`，先改写它的名称，让其变成`os.errClosed`，然后再编写`ErrClosed`函数和`IsErrClosed`函数。
    - 再来说**第二个方案**，此方案存在于`syscall`包中。该包中有一个类型叫做`Errno`，该类型代表了系统调用时可能发生的底层错误。这个错误类型是`error`接口的实现类型，同时也是对内建类型`uintptr`的再定义类型。
    - 由于`uintptr`可以作为常量的类型，所以`syscall.Errno`自然也可以。**`syscall`包中声明有大量的`Errno`类型的常量，每个常量都对应一种系统调用错误。`syscall`包外的代码可以拿到这些代表错误的常量，但却无法改变它们。**
    - **我们可以仿照这种声明方式来构建我们自己的错误值列表，这样就可以保证错误值的只读特性了。**
    - 不过需要注意的是，**如果它们是公开的，那就应该尽量让它们成为常量而不是变量，或者编写私有的错误值以及公开的获取和判等函数，否则就很难避免恶意的篡改。**
    - 这其实是“**最小化访问权限”**这个程序设计原则的一个具体体现。无论怎样设计程序错误体系，我们都应该把这一点考虑在内。





# panic、recover以及defer

- 运行时恐慌 panic

  - 这种异常只会在程序运行的时候被抛出来（例如数组越界）。
  - 当 panic 被抛出之后，如果我们没有在程序里添加任何保护措施的话，程序（或者说代表它的那个进程）就会在打印出 panic 的详细情况（以下简称 panic 详情）之后，终止运行。

- 从 panic 被引发到程序终止运行的大致过程是什么

  - 大致的过程：某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。
    - 这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻的停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。
    - **这里的最外层函数指的是`go`函数，对于主 goroutine 来说就是`main`函数。**但是控制权也不会停留在那里，而是**被 Go 语言运行时系统收回。**
  - **随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。**与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

- 除此之外，我们还是可以有意地引发 panic

  - Go 语言的内建函数`panic`是专门用于引发 panic 的。`panic`函数使程序开发者可以在程序运行期间报告异常。
    - 注意，这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非`nil`的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。
    - 但是，当一个 panic 发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃，就像前面描述的那样，这显然是致命的。
  - **panic 详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。**

- 怎样让 panic 包含一个值，以及应该让它包含什么样的值

  - 在调用`panic`函数时，把某个值作为参数传给该函数就可以了。**由于`panic`函数的唯一一个参数是空接口（也就是`interface{}`）类型的，所以从语法上讲，它可以接受任何类型的值。**
  - **但是，我们最好传入`error`类型的错误值，或者其他的可以被有效序列化的值**。这里的“有效序列化”指的是，可以更易读地去表示形式转换。
  - **对于`fmt`包下的各种打印函数来说，`error`类型值的`Error`方法与其他类型值的`String`方法是等价的**，它们的唯一结果都是`string`类型的。
  - 所以，如果你觉得某个值有可能会被**记到日志里**，那么就应该为它关联`String`方法。如果这个值是`error`类型的，那么让它的`Error`方法返回你为它定制的字符串表示形式就可以了。

- 怎样施加应对 panic 的保护措施，从而避免程序崩溃

  - Go 语言的内建函数`recover`专用于恢复 panic，或者说平息运行时恐慌。**`recover`函数无需任何参数，并且会返回一个空接口类型的值。**
  - panic 一旦发生，控制权就会讯速地沿着调用栈的反方向传播。所以，**在`panic`函数调用之后的代码，根本就没有执行的机会。**

- 到底什么才是正确的`recover`函数用法呢？这就不得不提到`defer`语句了。

  - `defer`语句就是被用来延迟执行代码的。**注意，被延迟执行的是`defer`函数，而不是`defer`语句。**延迟到什么时候呢？这要**延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。**

  - 一个`defer`语句总是由一个`defer`关键字和一个调用表达式组成。

  - ```go
     
    func main() {
     fmt.Println("Enter function main.")
     defer func(){
      fmt.Println("Enter defer function.")
      if p := recover(); p != nil {
       fmt.Printf("panic: %s\n", p)
      }
      fmt.Println("Exit defer function.")
     }()
     // 引发 panic。
     panic(errors.New("something wrong"))
     fmt.Println("Exit function main.")
    }
    ```

- 如果一个函数中有多条`defer`语句，那么那几个`defer`函数调用的执行顺序是怎样的？

  - 在同一个函数中，`defer`函数调用的执行顺序与它们分别所属的`defer`语句的出现顺序（更严谨地说，是执行顺序）**完全相反**。
  - 当一个函数即将结束执行时，其中的写在最下边的`defer`函数调用会最先执行，其次是写在它上边、与它的距离最近的那个`defer`函数调用，以此类推，最上边的`defer`函数调用会最后一个执行。

- `defer`语句执行时发生的事情

  - 在`defer`语句每次执行的时候，Go 语言会把它携带的`defer`函数及其参数值另行存储到一个队列中。
  - 这个队列与该`defer`语句所属的函数是对应的，并且，它是先进后出（FILO）的，相**当于一个栈**。

- 我们可以在`defer`函数中恢复 panic，那么可以在其中引发 panic 吗

  - 如果defer中引发panic，那么在该段defer函数之前，需要另外一个defer来捕获该panic，并且代码中最后一个panic会被抛弃，由defer中的panic来成为最后的异常返回。

- 从语言设计上，不使用try-catch而是用defer-recover有什么优势

  -  这是两种完全不同的异常处理机制。Go语言的异常处理机制是两层的，defer和recover可以处理意外的的异常，而error接口及相关体系处理可预期的异常。
  - 我认为defer机制正是建立在goroutine机制之上的。因为每个函数都有可能成为go函数，所以**必须要把异常处理做到函数级别。**可以看到，**defer机制和error机制**都是以函数为边界的。**前者在函数级别上阻止会导致非正常控制流的意外异常外溢，而后者在函数级别上用正常的控制流向外传递可预期异常。**
  - defer是用来做函数级别的资源清理工作的，处理panic是兼职。





# 测试的基本规则和流程

- 我们可以为 Go 程序编写三类测试，即：功能测试（test）、基准测试（benchmark，也称性能测试），以及示例测试（example）。

- Go 语言对测试函数的名称和签名都有哪些规定

  - **对于功能测试函数来说，其名称必须以`Test`为前缀**，并且参数列表中只应有一个`*testing.T`类型的参数声明。
  - **对于性能测试函数来说，其名称必须以`Benchmark`为前缀**，并且唯一参数的类型必须是`*testing.B`类型的。
  - **对于示例测试函数来说，其名称必须以`Example`为前缀**，但对函数的参数列表没有强制规定。

- `go test`命令执行的主要测试流程是什么

  - `go test`命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。
  - 在准备工作顺利完成之后，`go test`命令就会针对每个被测代码包，**依次**地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。
    - 但是，为了加快测试速度，它通常会**并发地对多个被测代码包进行功能测试**，只不过，在**最后打印测试结果的时候，它会依照我们给定的顺序逐个进行**，这会让我们感觉到它是在完全串行地执行测试流程。
    - 另一方面，**由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。**更具体地说，只有在所有构建步骤都做完之后，`go test`命令才会真正地开始进行性能测试。

- 怎样解释功能测试的测试结果

  - ```go
    $ go test puzzlers/article20/q2
    ok   puzzlers/article20/q2 (cached)
    ```

  - go 命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行`go env GOCACHE`命令来查看缓存目录的路径。缓存的数据总是能够正确地反映出当时的各种源码文件、构建环境、编译器选项等等的真实情况。

  - 一旦有任何变动，缓存数据就会失效，go 命令就会再次真正地执行操作。所以我们并不用担心打印出的缓存数据不是实时的结果。go 命令会定期地删除最近未使用的缓存数据，但是，如果你想手动删除所有的缓存数据，运行一下`go clean -cache`命令就好了。

    - 此外，设置环境变量`GODEBUG`的值也可以稍稍地改变 go 命令的缓存行为。比如，**设置值为`gocacheverify=1`将会导致 go 命令绕过任何的缓存数据，而真正地执行操作并重新生成所有结果**，然后再去检查新的结果与现有的缓存数据是否一致。

  - **`t.Log`方法以及`t.Logf`方法**的作用，就是打印常规的测试日志，只不过当测试成功的时候，`go test`命令就不会打印这类日志了。如果你想在测试结果中看到所有的常规测试日志，那么可以在运行`go test`命令的时候加入标记`-v`。

    - 若我们想让某个测试函数在执行的过程中立即失败，则可以在该函数中调用`t.FailNow`方法。
    - 与`t.Fail()`不同，在`t.FailNow()`执行之后，当前函数会立即终止执行。换句话说，该行代码之后的所有代码都会失去执行机会。

- 怎样解释性能测试的测试结果

  - 我在运行`go test`命令的时候加了两个标记。**第一个标记及其值为`-bench=.`，只有有了这个标记，命令才会进行性能测试。**该标记的值`.`表明需要执行任意名称的性能测试函数

  - 第二个标记及其值是`-run=^$`，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。**该标记的值`^$`意味着：只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。**

  - 你可能已经看出来了，这两个标记的值都是**正则表达式**。实际上，它们只能以正则表达式为值。此外，如果运行`go test`命令的时候不加`-run`标记，那么就会使它执行被测代码包中的所有功能测试函数。

  - ```go
    $ go test -bench=. -run=^$ puzzlers/article20/q3
    goos: darwin
    goarch: amd64
    pkg: puzzlers/article20/q3
    BenchmarkGetPrimes-8      500000       2314 ns/op
    PASS
    ok   puzzlers/article20/q3 1.192s
    ```

    - **`BenchmarkGetPrimes-8`被称为单个性能测试的名称**，它表示命令执行了性能测试函数`BenchmarkGetPrimes`，并且当时所用的最大 P 数量为`8`。
      - **最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数**。这里的逻辑 CPU，也可以被称为 **CPU 核心**，但它**并不等同于计算机中真正的 CPU 核心**，**只是 Go 语言运行时系统内部的一个概念**，代表着它同时运行 goroutine 的能力。
      - 一台计算机的 CPU 核心的个数，意味着它能在同一时刻执行多少条程序指令，代表着它并行处理程序指令的能力。
      - 我们可以通过调用 `runtime.GOMAXPROCS`函数改变最大 P 数量，也可以在运行`go test`命令时，加入标记`-cpu`来设置一个最大 P 数量的列表，以供命令在多次测试时使用
    - 在性能测试名称右边的是，`go test`命令最后一次执行性能测试函数（即`BenchmarkGetPrimes`函数）的时候，**被测函数（即`GetPrimes`函数）被执行的实际次数。**
      - 但要注意，它指的是被测函数的执行次数，而不是性能测试函数的执行次数。
    - `2314 ns/op`表明单次执行`GetPrimes`函数的平均耗时为`2314`纳秒。这其实就是通过将最后一次执行测试函数时的执行时间，除以（被测函数的）执行次数而得出的。

- go help test

  - go test 的相关参数 可以用go help test去看
  - 一些更详细的参数说明需要敲 go help testflag 查看。
  - go test 也支持 go build 的一些参数，那些参数需要敲 go help build 查看，另外怎么指定代码包需要敲 go help packages 查看说明。





# 更多的测试手法

- `go test`命令的标记`-cpu`，它是用来设置测试执行最大 P 数量的列表的。

  -  P 是 processor 的缩写，每个 processor 都是一个可以承载若干个 G，且能够使这些 G 适时地与 M 进行对接并得到真正运行的中介。
  - 这里的 G 就是 goroutine 的缩写，可以被理解为 Go 语言自己实现的用户级线程。M 即为 machine 的缩写，代表着系统级线程，或者说操作系统内核级别的线程。
  - P 的数量意味着 Go 程序背后的运行时系统中，会有多少个用于承载可运行的 G 的队列存在。每一个队列都相当于一条流水线，它会源源不断地把可运行的 G 输送给空闲的 M，并使这两者对接。
  - 因此，**最大 P 数量就代表着 Go 语言运行时系统同时运行 goroutine 的能力，也可以被视为其中逻辑 CPU 的最大个数。而`go test`命令的`-cpu`标记正是用于设置这个最大个数的。**
  - 在默认情况下，最大 P 数量就等于当前计算机 CPU 核心的实际数量。

- 怎样设置`-cpu`标记的值，以及它会对测试流程产生什么样的影响

  - 标记`-cpu`的值应该是一个正整数的列表，该列表的表现形式为：以英文半角逗号分隔的多个整数字面量，比如`1,2,4`。
  - **针对于此值中的每一个正整数，`go test`命令都会先设置最大 P 数量为该数，然后再执行测试函数。**
  - **如果测试函数有多个，那么`go test`命令会依照此方式逐个执行。**
    - 以`1,2,4`为例，`go test`命令会先以`1`,`2`,`4`为最大 P 数量分别去执行第一个测试函数，之后再用同样的方式执行第二个测试函数，以此类推。

- `go test`命令每一次对性能测试函数的执行，都是一个探索的过程。它会在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数。

  - 在这个过程中，性能测试函数可能会被执行多次。为了以后描述方便，我们把这样一个探索的过程称为：**对性能测试函数的一次探索式执行**，这其中包含了对该函数的若干次执行，当然，肯定也包括了对被测程序更多次的执行。

- `-count`标记是专门用于重复执行测试函数的。它的值必须大于或等于`0`，并且默认值为`1`。

  - 如果我们在运行`go test`命令的时候追加了`-count 5`，那么对于每一个测试函数，命令都会在预设的不同条件下（比如不同的最大 P 数量下）分别重复执行五次。
  - 性能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 x `-count`标记的值 x 探索式执行中测试函数的实际执行次数
  - 功能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 x `-count`标记的值

- **在对 Go 程序执行某种自动化测试的过程中，测试日志会显得特别多，而且好多都是重复的。**

  - **比如，对于功能测试函数来说，我们通常没有必要重复执行它**，即使是在不同的最大 P 数量下也是如此。注意，这里所说的重复执行指的是，在被测程序的输入（比如说被测函数的参数值）相同情况下的多次执行。
    - 还有些时候，我们的程序会无法避免地依赖一些外部环境，比如数据库或者其他服务。这时，我们依然不应该让测试的反复执行成为检测手段，而应该在测试中通过仿造（mock）外部环境，来规避掉它们的不确定性。
  - **正好相反，对于性能测试函数来说，我们常常需要反复地执行**，并以此试图抹平当时的计算资源调度的细微差别对被测程序性能的影响。通过`-cpu`标记，我们还能够模拟被测程序在计算能力不同计算机中的性能表现。

- `-parallel`标记的作用是什么

  - 该标记的作用是：设置同一个被测代码包中的**功能测试函数的最大并发执行数**。该标记的默认值是测试运行时的最大 P 数量
  - `-parallel`标记对性能测试是无效的。当然了，对于性能测试来说，也是可以并发进行的，不过机制上会有所不同。

- 性能测试函数中的计时器是做什么用的

  - `testing.B`类型有这么几个指针方法：`StartTimer`、`StopTimer`和`ResetTimer`。这些方法都是用于操作当前的性能测试函数专属的计时器的。

  - 所谓的计时器，是一个逻辑上的概念，它其实是`testing.B`类型中一些字段的统称。这些字段用于记录：**当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。**

  - 试函数中，我们可以通过对`b.StartTimer`和`b.StopTimer`方法的联合运用，再去除掉任何一段代码的执行时间。

    - ```go
      // 先停止了当前测试函数的计时器，然后通过调用time.Sleep函数，模拟了一个比较耗时的额外操作，并且在给变量max赋值之后又启动了该计时器。
      func BenchmarkGetPrimes(b *testing.B) {
       b.StopTimer()
       time.Sleep(time.Millisecond * 500) // 模拟某个耗时但与被测程序关系不大的操作。
       max := 10000
       b.StartTimer()
       
       for i := 0; i < b.N; i++ {
        GetPrimes(max)
       }
      }
      ```

- `-benchmem`标记和`-benchtime`标记的作用分别是什么？

  - -benchmem 输出基准测试的**内存分配统计信息**。
  - -benchtime 用于**指定基准测试的探索式测试执行时间上限**

- 怎样在测试的时候开启测试覆盖度分析？如果开启，会有什么副作用吗？

  - **使用 -coverprofile=xxxx.out 输出覆盖率的out文件**，使用go tool cover -html=xxxx.out 命令转换成Html的覆盖率测试报告。
  - 覆盖率测试将被测试的代码拷贝一份，在每个语句块中加入bool标识变量，测试结束后统计覆盖率并输出成out文件，因此性能上会有一定的影响。
  - PS：**使用-covermode=count标识参数将插入的标识变量由bool类型转换为计数器**，在测试过程中，记录执行次数，用于找出被频繁执行的代码块，方便优化。





# sync.Mutex与sync.RWMutex

- 竞态条件、临界区与同步工具
  - 一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为**竞态条件（race condition）**，这往往会破坏共享数据的一致性。
  - **同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。**
  - 只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section）
  - **施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。**
  - **在 Go 语言中，可供我们选择的同步工具并不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称 mutex）。**`sync`包中的`Mutex`就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。
- 我们使用互斥锁时有哪些注意事项
  - 不要重复锁定互斥锁；
    - **一旦产生死锁，程序必然崩溃**
  - 不要忘记解锁互斥锁，必要时使用`defer`语句；
    - 如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用`defer`语句来对它进行解锁，而且这样的`defer`语句应该紧跟在锁定操作之后。这是最保险的一种做法。
  - 不要对尚未锁定或者已解锁的互斥锁解锁；
  - 不要在多个函数之间直接传递互斥锁。
    - Go 语言中的互斥锁是开箱即用的。换句话说，一旦我们声明了一个`sync.Mutex`类型的变量，就可以直接使用它了。
    - 不过要注意，该类型是一个**结构体类**型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的**副本**的产生。
    - 并且，**原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。**
    - 如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。



# 条件变量sync.Cond

- 条件变量与互斥锁

  - 条件变量是基于互斥锁的，**它必须有互斥锁的支撑才能发挥作用**。
  - 条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。**当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。**
  - **条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。**
    - 条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。
    - 我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。

- 先来创建如下几个变量

  - ```go
    var mailbox uint8
    var lock sync.RWMutex
    // 利用sync.NewCond函数创建它的指针值。这个函数需要一个sync.Locker类型的参数值。
    sendCond := sync.NewCond(&lock)
    recvCond := sync.NewCond(lock.RLocker())
    
    ```

  - `sync.Locker`其实是一个接口，在它的声明中只包含了两个方法定义，即：`Lock()`和`Unlock()`。`sync.Mutex`类型和`sync.RWMutex`类型都拥有`Lock`方法和`Unlock`方法，只不过它们都是**指针方法**。**因此，这两个类型的指针类型才是`sync.Locker`接口的实现类型。**

  - 为了初始化`recvCond`这个条件变量，我们需要的是`lock`变量中的读锁，并且还需要是`sync.Locker`类型的。

    - 可是，`lock`变量中用于对读锁进行锁定和解锁的方法却是`RLock`和`RUnlock`，它们与`sync.Locker`接口中定义的方法并不匹配。
    - 好在`sync.RWMutex`类型的`RLocker`方法可以实现这一需求。我们只要在调用`sync.NewCond`函数时，**传入调用表达式`lock.RLocker()`的结果值**，就可以使该函数返回符合要求的条件变量了。
    - 为什么说通过`lock.RLocker()`得来的值就是`lock`变量中的读锁呢？**实际上，这个值所拥有的`Lock`方法和`Unlock`方法，在其内部会分别调用`lock`变量的`RLock`方法和`RUnlock`方法。也就是说，前两个方法仅仅是后两个方法的代理而已。**

- `*sync.Cond`类型的值可以被传递吗？那`sync.Cond`类型的值呢？

  - 指针可以传递，值不可以，传递值会拷贝一份，导致出现两份条件变量，彼此之间没有联系

  - ```go
    // 指针类型可以被传递，因为底层数据是同一份。
    
    // 传值的话
    type Cond struct {
      noCopy noCopy
      // L is held while observing or changing the condition
      L Locker
      notify notifyList
      checker copyChecker
    }
    /*
    
    Locker 是接口，传递时是引用类型
    notifyList 是结构体，会被浅拷贝
    checker 是数值类型，也会被拷贝
    
    如果sync.Cond在传递过程中，结构体和数值类型各层都有一份备份数据，容易造成不一致情况，所以极容易出问题。
    
    */
    ```

- 条件变量的`Wait`方法做了什么

  - 把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。
  - **解锁当前的条件变量基于的那个互斥锁**。
    - 因为条件变量的`Wait`方法在阻塞当前的 goroutine 之前，会解锁它基于的互斥锁，所以在调用该`Wait`方法之前，我们必须先锁定那个互斥锁，否则在调用这个`Wait`方法时，就会引发一个不可恢复的 panic。
  - 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个`Wait`方法的那行代码上。
  - 如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的 goroutine 就会继续执行后面的代码了

- 为什么要用`for`语句来包裹调用其`Wait`方法的表达式

  - 这主要是为了保险起见。如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用条件变量的`Wait`方法，并继续等待下次通知的到来。

- 条件变量的`Signal`方法和`Broadcast`方法有哪些异同

  - 前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。
  - 请注意，条件变量的通知具有即时性。也就是说，如果发送通知的时候没有 goroutine 为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的 goroutine 只可能被后面的通知唤醒。

- `sync.Cond`类型中的公开字段`L`是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？

  - ```go
    // 这是个Locker，那么也是通过它来控制共享资源的并发访问。
    
    func (c *Cond) Wait() {
      c.checker.check()
      t := runtime_notifyListAdd(&c.notify)
      c.L.Unlock()
      runtime_notifyListWait(&c.notify, t)
      c.L.Lock()
    }
    func (c *Cond) Signal() {
      c.checker.check()
      runtime_notifyListNotifyOne(&c.notify)
    }
    func (c *Cond) Broadcast() {
      c.checker.check()
      runtime_notifyListNotifyAll(&c.notify)
    }
    
    // 很显然在wait时使用了以及外部逻辑使用了。随意更改这个值有可能引发panic
    ```

    



# 原子操作

- 原子性执行与原子操作

  - 对于一个 Go 程序来说，Go 语言运行时系统中的调度器会恰当地安排其中所有的 goroutine 的运行。不过，**在同一时刻，只可能有少数的 goroutine 真正地处于运行状态，并且这个数量只会与 M 的数量一致**，而不会随着 G 的增多而增长。
  - **所以，为了公平起见，调度器总是会频繁地换上或换下这些 goroutine**。
    - **换上**的意思是，让一个 goroutine 由非运行状态转为运行状态，并促使其中的代码在某个 CPU 核心上执行。
    - **换下**的意思正好相反，即：使一个 goroutine 中的代码中断执行，并让它由运行状态转为非运行状态。
    - **这个中断的时机有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。**
  - 互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）。
    - **在众多的同步工具中，真正能够保证原子性执行的只有[原子操作](https://baike.baidu.com/item/原子操作/1880992?fr=aladdin)（atomic operation）。**原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的。
  - **更具体地说，正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速。**

- `sync/atomic`包中提供了几种原子操作？可操作的数据类型又有哪些？

  - `sync/atomic`包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。
  - 这些函数针对的数据类型并不多。但是，对这些类型中的每一个，`sync/atomic`包都会有一套函数给予支持。这些数据类型有：`int32`、`int64`、`uint32`、`uint64`、`uintptr`，以及`unsafe`包中的`Pointer`。不过，**针对`unsafe.Pointer`类型，该包并未提供进行原子加法操作的函数。**
  - 此外，`sync/atomic`包还提供了一个名为`Value`的类型，它可以被用来存储任意类型的值。

- 我们都知道，传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，**`atomic.AddInt32`函数的第一个参数**，对应的一定是那个要被增大的整数。可是，**这个参数的类型为什么不是`int32`而是`*int32`呢？**

  - 因为**原子操作函数需要的是被操作值的指针，而不是这个值本身**；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，就已经与函数外的那个值毫无关系了。
  - 只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据。

- 用于原子加法操作的函数可以做原子减法吗？比如，`atomic.AddInt32`函数可以用于减小那个被操作的整数值吗？

  - **`atomic.AddInt32`函数的第二个参数代表差量，它的类型是`int32`，是有符号的。**如果我们想做原子减法，那么把这个差量设置为负整数就可以了。
  - 对于`atomic.AddInt64`函数来说也是类似的。不过，**要想用`atomic.AddUint32`和`atomic.AddUint64`函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是`uint32`和`uint64`，都是无符号的**，不过，这也是可以做到的，就是稍微麻烦一些。
    - 例如，如果想对`uint32`类型的被操作值`18`做原子减法，比如说差量是`-3`，那么我们可以先把这个差量转换为有符号的`int32`类型的值，然后再把该值的类型转换为`uint32`，用表达式来描述就是`uint32(int32(-3))`。
    - 不过要注意，直接这样写会使 Go 语言的编译器报错，它会告诉你：“常量`-3`不在`uint32`类型可表示的范围内”，换句话说，这样做会让表达式的结果值溢出。
    - 不过，如果我们**先把`int32(-3)`的结果值赋给变量`delta`**，再把`delta`的值转换为`uint32`类型的值，就可以**绕过编译器的检查**并得到正确的结果了。
    - 最后，我们把这个结果作为`atomic.AddUint32`函数的第二个参数值，就可以达到对`uint32`类型的值做原子减法的目的了。
  - 一种更加直接的方式。我们可以依据下面这个表达式来给定`atomic.AddUint32`函数的第二个参数值：^uint32(-N-1))
  - 其中的`N`代表由负整数表示的差量。也就是说，我们先要把差量的绝对值减去`1`，然后再把得到的这个无类型的整数常量，转换为`uint32`类型的值，最后，在这个值之上做按位异或操作，就可以获得最终的参数值了。

- 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？

  - 

  



































